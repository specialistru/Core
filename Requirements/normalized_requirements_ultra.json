[
  {
    "id": "REQ-0.1",
    "category": "0. Инициализация и системный старт",
    "title": "Точка входа и инициализация subsystems",
    "description": "Система должна иметь точку входа (main), выполняющую загрузку конфигурации, инициализацию логгера, создание экземпляра БД и запуск сетевых интерфейсов. Это критически важный компонент, который должен обеспечивать предсказуемое поведение и быть устойчивым к сбоям в любых условиях запуска. Он должен гарантировать, что система запускается полностью, с инициализацией всех подсистем и логгированием ошибок. Также он должен быть покрыт unit и soak тестами для обеспечения качества.",
    "priority": "critical",
    "status": "approved",
    "test_coverage": true,
    "test_type": "unit",
    "covered_by_blocks": [
      "0.1",
      "0.2"
    ],
    "covered_by_metrics": [
      "startup_duration_ms",
      "init_errors_total"
    ],
    "responsible_roles": [
      "Startup Engineer",
      "DevOps Integrator"
    ],
    "description_en": "Phone food outside up past many. Size sometimes call director play scientist blue. Ability thank letter democratic. You actually become rule church identify despite industry. Decision campaign debate.",
    "test_spec": {
      "goal": "Проверить, что точка входа (main) корректно инициализирует все подсистемы.",
      "input": [
        "Запуск бинаря без параметров",
        "ENV-переменные с путём к конфигу"
      ],
      "expected": [
        "Метрика startup_duration_ms > 0",
        "WAL инициализирован",
        "Сессия БД создана",
        "Выходной код 0"
      ],
      "tools": [
        "unit",
        "integration",
        "log capture"
      ]
    },
    "code_module": "src/main.c",
    "tracing_required": true,
    "perf_budget_ns": {
      "startup": 2000000,
      "logger_init": 0
    },
    "impl_hint": [
      "Инициализация логгера должна происходить первой",
      "Создание экземпляра db_t — через db_instance_create()",
      "Использовать логгирование ошибок при каждом шаге"
    ],
    "functions_to_implement": [
      "main()",
      "db_instance_create()",
      "load_config()"
    ],
    "required_structures": [
      "db_t",
      "config_t"
    ],
    "log_events_to_emit": [
      "startup_begin",
      "startup_success",
      "startup_failed"
    ],
    "config_keys_used": [
      "db.config_path",
      "db.instance_id"
    ],
    "runtime_metrics_to_emit": [
      "startup_duration_ms",
      "init_errors_total"
    ],
    "fault_injection_points": [
      "db_instance_create"
    ],
    "related_requirements": [
      "REQ-0.2",
      "REQ-0.3"
    ]
  },
  {
    "id": "REQ-0.2",
    "category": "0. Инициализация и системный старт",
    "title": "Инициализация логгера и runtime-конфигурации",
    "description": "Система должна поддерживать конфигурируемый логгер (stderr, syslog, binary) и загрузку конфигурации из CLI/ENV/файлов. Это критически важный компонент, который должен обеспечивать предсказуемое поведение и быть устойчивым к сбоям в любых условиях запуска. Он должен гарантировать, что система запускается полностью, с инициализацией всех подсистем и логгированием ошибок. Также он должен быть покрыт unit и soak тестами для обеспечения качества.",
    "priority": "critical",
    "status": "approved",
    "test_coverage": true,
    "test_type": "unit",
    "covered_by_blocks": [
      "0.3",
      "0.4"
    ],
    "covered_by_metrics": [
      "log_config_load_time_ms",
      "logger_mode"
    ],
    "responsible_roles": [
      "Observability Engineer",
      "DevOps Integrator"
    ],
    "description_en": "Scene involve not consumer artist approach oil. Discussion safe open share attention. Citizen process prove capital.",
    "test_spec": {
      "goal": "Убедиться, что логгер и конфигурация загружаются из CLI/ENV/файла.",
      "input": [
        "--config /etc/db.yml",
        "ENV CONFIG_FILE"
      ],
      "expected": [
        "log_config_load_time_ms < 500",
        "logger_mode == 'binary'",
        "Файл конфигурации успешно прочитан"
      ],
      "tools": [
        "unit",
        "mock fs",
        "stderr capture"
      ]
    },
    "code_module": "src/main.c",
    "tracing_required": true,
    "perf_budget_ns": {
      "startup": 1000000,
      "logger_init": 500000
    },
    "impl_hint": [
      "Поддержка логгера в трех режимах: stderr, syslog, binary",
      "Конфигурация может приходить через CLI, ENV, файл"
    ],
    "functions_to_implement": [
      "init_logger()",
      "load_log_config()"
    ],
    "required_structures": [
      "log_config_t"
    ],
    "log_events_to_emit": [
      "log_config_loaded",
      "log_mode_set"
    ],
    "config_keys_used": [
      "db.log_mode",
      "db.log_level"
    ],
    "runtime_metrics_to_emit": [
      "log_config_load_time_ms",
      "logger_mode"
    ],
    "fault_injection_points": [
      "load_log_config"
    ],
    "related_requirements": [
      "REQ-0.1"
    ]
  },
  {
    "id": "REQ-0.3",
    "category": "0. Инициализация и системный старт",
    "title": "Загрузка подсистем (WAL, GC, Metrics)",
    "description": "После инициализации конфигурации система должна загрузить подсистемы WAL, MVCC, GC, и метрик в изолированных потоках. Это критически важный компонент, который должен обеспечивать предсказуемое поведение и быть устойчивым к сбоям в любых условиях запуска. Он должен гарантировать, что система запускается полностью, с инициализацией всех подсистем и логгированием ошибок. Также он должен быть покрыт unit и soak тестами для обеспечения качества.",
    "priority": "high",
    "status": "approved",
    "test_coverage": true,
    "test_type": "integration",
    "covered_by_blocks": [
      "0.5",
      "0.6",
      "0.7"
    ],
    "covered_by_metrics": [
      "wal_writer_init_time_ms",
      "metrics_collector_init_total"
    ],
    "responsible_roles": [
      "Runtime Engineer",
      "Transaction Engineer"
    ],
    "description_en": "Support physical movement standard. Tv while common road. Avoid return tree bad. Something wall down with.",
    "test_spec": {
      "goal": "Проверить запуск WAL, GC, Metrics collector.",
      "input": [
        "main() с валидной конфигурацией"
      ],
      "expected": [
        "Подсистемы запущены в отдельных потоках",
        "wal_writer_init_time_ms > 0",
        "metrics_collector_init_total == 1"
      ],
      "tools": [
        "integration",
        "thread tracing"
      ]
    },
    "code_module": "src/main.c",
    "tracing_required": true,
    "perf_budget_ns": {
      "startup": 1000000,
      "logger_init": 0
    },
    "impl_hint": [
      "Каждая подсистема запускается в отдельном потоке",
      "Отслеживать время и статус запуска через метрики"
    ],
    "functions_to_implement": [
      "wal_init()",
      "metrics_collector_start()",
      "gc_start()"
    ],
    "required_structures": [
      "wal_config_t",
      "gc_thread_t"
    ],
    "log_events_to_emit": [
      "wal_init_start",
      "metrics_collector_init"
    ],
    "config_keys_used": [
      "db.wal_enabled"
    ],
    "runtime_metrics_to_emit": [
      "wal_writer_init_time_ms",
      "metrics_collector_init_total"
    ],
    "fault_injection_points": [
      "wal_init",
      "gc_start"
    ],
    "related_requirements": [
      "REQ-0.1",
      "REQ-0.2"
    ]
  },
  {
    "id": "REQ-0.4",
    "category": "0. Инициализация и системный старт",
    "title": "Запуск сетевого уровня и REST/gRPC API",
    "description": "Инициализация сетевых интерфейсов должна происходить после загрузки ядра. Поддерживается REST/gRPC/GraphQL с runtime-индикаторами. Это критически важный компонент, который должен обеспечивать предсказуемое поведение и быть устойчивым к сбоям в любых условиях запуска. Он должен гарантировать, что система запускается полностью, с инициализацией всех подсистем и логгированием ошибок. Также он должен быть покрыт unit и soak тестами для обеспечения качества.",
    "priority": "high",
    "status": "approved",
    "test_coverage": true,
    "test_type": "e2e",
    "covered_by_blocks": [
      "0.8",
      "0.9"
    ],
    "covered_by_metrics": [
      "http_server_startup_latency_ms",
      "api_handler_register_total"
    ],
    "responsible_roles": [
      "Network Engineer",
      "API Architect"
    ],
    "description_en": "Million spring reduce leave under check to. Market talk perform reflect. Everything and laugh pick save. Also win support word. Bank mouth time. Discuss young meet successful message challenge professor.",
    "test_spec": {
      "goal": "Проверить, что REST/gRPC интерфейсы запускаются после ядра.",
      "input": [
        "main()",
        "GET /metrics",
        "gRPC healthcheck"
      ],
      "expected": [
        "http_server_startup_latency_ms > 0",
        "Ответ на REST-запрос 200 OK",
        "Все маршруты зарегистрированы"
      ],
      "tools": [
        "e2e",
        "API test client"
      ]
    },
    "code_module": "src/main.c",
    "tracing_required": true,
    "perf_budget_ns": {
      "startup": 1000000,
      "logger_init": 0
    },
    "impl_hint": [
      "REST/gRPC запускаются после инициализации ядра",
      "Каждый маршрут регистрируется в структуре api_registry"
    ],
    "functions_to_implement": [
      "start_rest_api()",
      "register_routes()"
    ],
    "required_structures": [
      "api_registry_t"
    ],
    "log_events_to_emit": [
      "http_server_started"
    ],
    "config_keys_used": [
      "db.api.rest.enabled",
      "db.api.grpc.enabled"
    ],
    "runtime_metrics_to_emit": [
      "http_server_startup_latency_ms",
      "api_handler_register_total"
    ],
    "fault_injection_points": [
      "start_rest_api"
    ],
    "related_requirements": [
      "REQ-0.3"
    ]
  },
  {
    "id": "REQ-0.5",
    "category": "0. Инициализация и системный старт",
    "title": "Завершение работы и очистка ресурсов",
    "description": "Система должна корректно обрабатывать SIGINT/SIGTERM, закрывая соединения, останавливая фоновые процессы и сбрасывая состояния WAL. Это критически важный компонент, который должен обеспечивать предсказуемое поведение и быть устойчивым к сбоям в любых условиях запуска. Он должен гарантировать, что система запускается полностью, с инициализацией всех подсистем и логгированием ошибок. Также он должен быть покрыт unit и soak тестами для обеспечения качества.",
    "priority": "critical",
    "status": "approved",
    "test_coverage": true,
    "test_type": "soak",
    "covered_by_blocks": [
      "0.10",
      "0.11"
    ],
    "covered_by_metrics": [
      "graceful_shutdown_latency_ms",
      "background_tasks_shutdown_total"
    ],
    "responsible_roles": [
      "DevOps Integrator",
      "Transaction Engineer"
    ],
    "description_en": "Describe tonight serve rich six become. Of office age particular popular happy yes least. Including whom west themselves. Result tell major second dream set school end. Large describe network positive policy few movement.",
    "test_spec": {
      "goal": "Проверить корректное завершение и освобождение ресурсов.",
      "input": [
        "SIGINT",
        "SIGTERM",
        "kill -9"
      ],
      "expected": [
        "graceful_shutdown_latency_ms < 5000",
        "Все background потоки завершены",
        "Файлы WAL закрыты"
      ],
      "tools": [
        "soak",
        "signal simulation",
        "log inspection"
      ]
    },
    "code_module": "src/main.c",
    "tracing_required": true,
    "perf_budget_ns": {
      "startup": 1000000,
      "logger_init": 0
    },
    "impl_hint": [
      "Обработка SIGINT и SIGTERM должна вызывать graceful_shutdown()",
      "Фоновые потоки завершаются через condition variable"
    ],
    "functions_to_implement": [
      "graceful_shutdown()",
      "stop_background_threads()"
    ],
    "required_structures": [
      "shutdown_state_t"
    ],
    "log_events_to_emit": [
      "shutdown_start",
      "shutdown_complete"
    ],
    "config_keys_used": [
      "db.shutdown.timeout"
    ],
    "runtime_metrics_to_emit": [
      "graceful_shutdown_latency_ms",
      "background_tasks_shutdown_total"
    ],
    "fault_injection_points": [
      "graceful_shutdown"
    ],
    "related_requirements": [
      "REQ-0.3",
      "REQ-0.4"
    ]
  },
  {
    "id": "REQ-1.1",
    "category": "1. Архитектура и Хранилище",
    "title": "Полностью in-memory выполнение с fallback на NVMe/SSD (tiered storage)",
    "description": "Полностью in-memory выполнение с fallback на NVMe/SSD (tiered storage) должно быть реализовано с учётом высокой производительности, отказоустойчивости и соответствия архитектурным требованиям SAP HANA+.",
    "description_en": "Полностью in-memory выполнение с fallback на NVMe/SSD (tiered storage) must be implemented with high performance, fault tolerance and SAP HANA+ grade compliance.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "1.1"
    ],
    "code_module": "src/storage.c",
    "responsible_roles": [
      "storage_architect",
      "performance_engineer"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверить реализацию 'Полностью in-memory выполнение с fallback на NVMe/SSD (tiered storage)' на соответствие in-memory архитектуре",
      "input": [
        "Конфигурация",
        "SQL-запросы",
        "нагрузка на shard/partition"
      ],
      "expected": [
        "Выполнение < 1мс",
        "eviction/flush сработали",
        "метрики сгенерированы"
      ],
      "tools": [
        "integration test",
        "perf replay",
        "metrics collector"
      ]
    }
  },
  {
    "id": "REQ-1.2",
    "category": "1. Архитектура и Хранилище",
    "title": "Гибридное хранение: row-store, column-store, JSON store",
    "description": "Гибридное хранение: row-store, column-store, JSON store должно быть реализовано с учётом высокой производительности, отказоустойчивости и соответствия архитектурным требованиям SAP HANA+.",
    "description_en": "Гибридное хранение: row-store, column-store, JSON store must be implemented with high performance, fault tolerance and SAP HANA+ grade compliance.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "1.2"
    ],
    "code_module": "src/storage.c",
    "responsible_roles": [
      "storage_architect",
      "performance_engineer"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверить реализацию 'Гибридное хранение: row-store, column-store, JSON store' на соответствие in-memory архитектуре",
      "input": [
        "Конфигурация",
        "SQL-запросы",
        "нагрузка на shard/partition"
      ],
      "expected": [
        "Выполнение < 1мс",
        "eviction/flush сработали",
        "метрики сгенерированы"
      ],
      "tools": [
        "integration test",
        "perf replay",
        "metrics collector"
      ]
    }
  },
  {
    "id": "REQ-1.3",
    "category": "1. Архитектура и Хранилище",
    "title": "NUMA-aware allocation, CPU-affinity, cache coloring, prefetch",
    "description": "NUMA-aware allocation, CPU-affinity, cache coloring, prefetch должно быть реализовано с учётом высокой производительности, отказоустойчивости и соответствия архитектурным требованиям SAP HANA+.",
    "description_en": "NUMA-aware allocation, CPU-affinity, cache coloring, prefetch must be implemented with high performance, fault tolerance and SAP HANA+ grade compliance.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "1.3"
    ],
    "code_module": "src/storage.c",
    "responsible_roles": [
      "storage_architect",
      "performance_engineer"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверить реализацию 'NUMA-aware allocation, CPU-affinity, cache coloring, prefetch' на соответствие in-memory архитектуре",
      "input": [
        "Конфигурация",
        "SQL-запросы",
        "нагрузка на shard/partition"
      ],
      "expected": [
        "Выполнение < 1мс",
        "eviction/flush сработали",
        "метрики сгенерированы"
      ],
      "tools": [
        "integration test",
        "perf replay",
        "metrics collector"
      ]
    }
  },
  {
    "id": "REQ-1.4",
    "category": "1. Архитектура и Хранилище",
    "title": "Масштабирование: sharding, partitioning, auto-rebalancing, distributed planner",
    "description": "Масштабирование: sharding, partitioning, auto-rebalancing, distributed planner должно быть реализовано с учётом высокой производительности, отказоустойчивости и соответствия архитектурным требованиям SAP HANA+.",
    "description_en": "Масштабирование: sharding, partitioning, auto-rebalancing, distributed planner must be implemented with high performance, fault tolerance and SAP HANA+ grade compliance.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "1.4"
    ],
    "code_module": "src/storage.c",
    "responsible_roles": [
      "storage_architect",
      "performance_engineer"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверить реализацию 'Масштабирование: sharding, partitioning, auto-rebalancing, distributed planner' на соответствие in-memory архитектуре",
      "input": [
        "Конфигурация",
        "SQL-запросы",
        "нагрузка на shard/partition"
      ],
      "expected": [
        "Выполнение < 1мс",
        "eviction/flush сработали",
        "метрики сгенерированы"
      ],
      "tools": [
        "integration test",
        "perf replay",
        "metrics collector"
      ]
    }
  },
  {
    "id": "REQ-1.5",
    "category": "1. Архитектура и Хранилище",
    "title": "Индексы: B+ tree, hash, bitmap, inverted, adaptive indexing",
    "description": "Индексы: B+ tree, hash, bitmap, inverted, adaptive indexing должно быть реализовано с учётом высокой производительности, отказоустойчивости и соответствия архитектурным требованиям SAP HANA+.",
    "description_en": "Индексы: B+ tree, hash, bitmap, inverted, adaptive indexing must be implemented with high performance, fault tolerance and SAP HANA+ grade compliance.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "1.5"
    ],
    "code_module": "src/storage.c",
    "responsible_roles": [
      "storage_architect",
      "performance_engineer"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверить реализацию 'Индексы: B+ tree, hash, bitmap, inverted, adaptive indexing' на соответствие in-memory архитектуре",
      "input": [
        "Конфигурация",
        "SQL-запросы",
        "нагрузка на shard/partition"
      ],
      "expected": [
        "Выполнение < 1мс",
        "eviction/flush сработали",
        "метрики сгенерированы"
      ],
      "tools": [
        "integration test",
        "perf replay",
        "metrics collector"
      ]
    }
  },
  {
    "id": "REQ-1.6",
    "category": "1. Архитектура и Хранилище",
    "title": "Сжатие: dictionary, RLE, delta, frame-of-reference, vectorized decompression",
    "description": "Сжатие: dictionary, RLE, delta, frame-of-reference, vectorized decompression должно быть реализовано с учётом высокой производительности, отказоустойчивости и соответствия архитектурным требованиям SAP HANA+.",
    "description_en": "Сжатие: dictionary, RLE, delta, frame-of-reference, vectorized decompression must be implemented with high performance, fault tolerance and SAP HANA+ grade compliance.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "1.6"
    ],
    "code_module": "src/storage.c",
    "responsible_roles": [
      "storage_architect",
      "performance_engineer"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверить реализацию 'Сжатие: dictionary, RLE, delta, frame-of-reference, vectorized decompression' на соответствие in-memory архитектуре",
      "input": [
        "Конфигурация",
        "SQL-запросы",
        "нагрузка на shard/partition"
      ],
      "expected": [
        "Выполнение < 1мс",
        "eviction/flush сработали",
        "метрики сгенерированы"
      ],
      "tools": [
        "integration test",
        "perf replay",
        "metrics collector"
      ]
    }
  },
  {
    "id": "REQ-1.7",
    "category": "1. Архитектура и Хранилище",
    "title": "Page Cache / Buffer Pool: LRU, ARC, dirty tracking, preload pages",
    "description": "Page Cache / Buffer Pool: LRU, ARC, dirty tracking, preload pages должно быть реализовано с учётом высокой производительности, отказоустойчивости и соответствия архитектурным требованиям SAP HANA+.",
    "description_en": "Page Cache / Buffer Pool: LRU, ARC, dirty tracking, preload pages must be implemented with high performance, fault tolerance and SAP HANA+ grade compliance.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "1.7"
    ],
    "code_module": "src/storage.c",
    "responsible_roles": [
      "storage_architect",
      "performance_engineer"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверить реализацию 'Page Cache / Buffer Pool: LRU, ARC, dirty tracking, preload pages' на соответствие in-memory архитектуре",
      "input": [
        "Конфигурация",
        "SQL-запросы",
        "нагрузка на shard/partition"
      ],
      "expected": [
        "Выполнение < 1мс",
        "eviction/flush сработали",
        "метрики сгенерированы"
      ],
      "tools": [
        "integration test",
        "perf replay",
        "metrics collector"
      ]
    }
  },
  {
    "id": "REQ-1.8",
    "category": "1. Архитектура и Хранилище",
    "title": "WAL: log compaction, параллельные WAL writers, diff-based snapshot",
    "description": "WAL: log compaction, параллельные WAL writers, diff-based snapshot должно быть реализовано с учётом высокой производительности, отказоустойчивости и соответствия архитектурным требованиям SAP HANA+.",
    "description_en": "WAL: log compaction, параллельные WAL writers, diff-based snapshot must be implemented with high performance, fault tolerance and SAP HANA+ grade compliance.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "1.8"
    ],
    "code_module": "src/storage.c",
    "responsible_roles": [
      "storage_architect",
      "performance_engineer"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверить реализацию 'WAL: log compaction, параллельные WAL writers, diff-based snapshot' на соответствие in-memory архитектуре",
      "input": [
        "Конфигурация",
        "SQL-запросы",
        "нагрузка на shard/partition"
      ],
      "expected": [
        "Выполнение < 1мс",
        "eviction/flush сработали",
        "метрики сгенерированы"
      ],
      "tools": [
        "integration test",
        "perf replay",
        "metrics collector"
      ]
    }
  },
  {
    "id": "REQ-1.9",
    "category": "1. Архитектура и Хранилище",
    "title": "Горячие/холодные данные, auto-tiering, TTL, eviction",
    "description": "Горячие/холодные данные, auto-tiering, TTL, eviction должно быть реализовано с учётом высокой производительности, отказоустойчивости и соответствия архитектурным требованиям SAP HANA+.",
    "description_en": "Горячие/холодные данные, auto-tiering, TTL, eviction must be implemented with high performance, fault tolerance and SAP HANA+ grade compliance.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "1.9"
    ],
    "code_module": "src/storage.c",
    "responsible_roles": [
      "storage_architect",
      "performance_engineer"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверить реализацию 'Горячие/холодные данные, auto-tiering, TTL, eviction' на соответствие in-memory архитектуре",
      "input": [
        "Конфигурация",
        "SQL-запросы",
        "нагрузка на shard/partition"
      ],
      "expected": [
        "Выполнение < 1мс",
        "eviction/flush сработали",
        "метрики сгенерированы"
      ],
      "tools": [
        "integration test",
        "perf replay",
        "metrics collector"
      ]
    }
  },
  {
    "id": "REQ-1.10",
    "category": "1. Архитектура и Хранилище",
    "title": "PAX / Apache Arrow layouts, copy-on-write snapshots, instant clone",
    "description": "PAX / Apache Arrow layouts, copy-on-write snapshots, instant clone должно быть реализовано с учётом высокой производительности, отказоустойчивости и соответствия архитектурным требованиям SAP HANA+.",
    "description_en": "PAX / Apache Arrow layouts, copy-on-write snapshots, instant clone must be implemented with high performance, fault tolerance and SAP HANA+ grade compliance.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "1.10"
    ],
    "code_module": "src/storage.c",
    "responsible_roles": [
      "storage_architect",
      "performance_engineer"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверить реализацию 'PAX / Apache Arrow layouts, copy-on-write snapshots, instant clone' на соответствие in-memory архитектуре",
      "input": [
        "Конфигурация",
        "SQL-запросы",
        "нагрузка на shard/partition"
      ],
      "expected": [
        "Выполнение < 1мс",
        "eviction/flush сработали",
        "метрики сгенерированы"
      ],
      "tools": [
        "integration test",
        "perf replay",
        "metrics collector"
      ]
    }
  },
  {
    "id": "REQ-1.11",
    "category": "1. Архитектура и Хранилище",
    "title": "Системные таблицы и временное хранение",
    "description": "Системные таблицы и временное хранение должно быть реализовано с учётом высокой производительности, отказоустойчивости и соответствия архитектурным требованиям SAP HANA+.",
    "description_en": "Системные таблицы и временное хранение must be implemented with high performance, fault tolerance and SAP HANA+ grade compliance.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "1.11"
    ],
    "code_module": "src/storage.c",
    "responsible_roles": [
      "storage_architect",
      "performance_engineer"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверить реализацию 'Системные таблицы и временное хранение' на соответствие in-memory архитектуре",
      "input": [
        "Конфигурация",
        "SQL-запросы",
        "нагрузка на shard/partition"
      ],
      "expected": [
        "Выполнение < 1мс",
        "eviction/flush сработали",
        "метрики сгенерированы"
      ],
      "tools": [
        "integration test",
        "perf replay",
        "metrics collector"
      ]
    }
  },
  {
    "id": "REQ-1.12",
    "category": "1. Архитектура и Хранилище",
    "title": "Column-level statistics и data distribution",
    "description": "Column-level statistics и data distribution должно быть реализовано с учётом высокой производительности, отказоустойчивости и соответствия архитектурным требованиям SAP HANA+.",
    "description_en": "Column-level statistics и data distribution must be implemented with high performance, fault tolerance and SAP HANA+ grade compliance.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "1.12"
    ],
    "code_module": "src/storage.c",
    "responsible_roles": [
      "storage_architect",
      "performance_engineer"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверить реализацию 'Column-level statistics и data distribution' на соответствие in-memory архитектуре",
      "input": [
        "Конфигурация",
        "SQL-запросы",
        "нагрузка на shard/partition"
      ],
      "expected": [
        "Выполнение < 1мс",
        "eviction/flush сработали",
        "метрики сгенерированы"
      ],
      "tools": [
        "integration test",
        "perf replay",
        "metrics collector"
      ]
    }
  },
  {
    "id": "REQ-1.13",
    "category": "1. Архитектура и Хранилище",
    "title": "SYSTEM VERSIONED таблицы и AS OF запросы",
    "description": "SYSTEM VERSIONED таблицы и AS OF запросы должно быть реализовано с учётом высокой производительности, отказоустойчивости и соответствия архитектурным требованиям SAP HANA+.",
    "description_en": "SYSTEM VERSIONED таблицы и AS OF запросы must be implemented with high performance, fault tolerance and SAP HANA+ grade compliance.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "1.13"
    ],
    "code_module": "src/storage.c",
    "responsible_roles": [
      "storage_architect",
      "performance_engineer"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверить реализацию 'SYSTEM VERSIONED таблицы и AS OF запросы' на соответствие in-memory архитектуре",
      "input": [
        "Конфигурация",
        "SQL-запросы",
        "нагрузка на shard/partition"
      ],
      "expected": [
        "Выполнение < 1мс",
        "eviction/flush сработали",
        "метрики сгенерированы"
      ],
      "tools": [
        "integration test",
        "perf replay",
        "metrics collector"
      ]
    }
  },
  {
    "id": "REQ-1.14",
    "category": "1. Архитектура и Хранилище",
    "title": "NUMA-aware eviction и GC",
    "description": "NUMA-aware eviction и GC должно быть реализовано с учётом высокой производительности, отказоустойчивости и соответствия архитектурным требованиям SAP HANA+.",
    "description_en": "NUMA-aware eviction и GC must be implemented with high performance, fault tolerance and SAP HANA+ grade compliance.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "1.14"
    ],
    "code_module": "src/storage.c",
    "responsible_roles": [
      "storage_architect",
      "performance_engineer"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверить реализацию 'NUMA-aware eviction и GC' на соответствие in-memory архитектуре",
      "input": [
        "Конфигурация",
        "SQL-запросы",
        "нагрузка на shard/partition"
      ],
      "expected": [
        "Выполнение < 1мс",
        "eviction/flush сработали",
        "метрики сгенерированы"
      ],
      "tools": [
        "integration test",
        "perf replay",
        "metrics collector"
      ]
    }
  },
  {
    "id": "REQ-1.15",
    "category": "1. Архитектура и Хранилище",
    "title": "Поддержка multi-tenant isolation на уровне shard/partition",
    "description": "Поддержка multi-tenant isolation на уровне shard/partition должно быть реализовано с учётом высокой производительности, отказоустойчивости и соответствия архитектурным требованиям SAP HANA+.",
    "description_en": "Поддержка multi-tenant isolation на уровне shard/partition must be implemented with high performance, fault tolerance and SAP HANA+ grade compliance.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "1.15"
    ],
    "code_module": "src/storage.c",
    "responsible_roles": [
      "storage_architect",
      "performance_engineer"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверить реализацию 'Поддержка multi-tenant isolation на уровне shard/partition' на соответствие in-memory архитектуре",
      "input": [
        "Конфигурация",
        "SQL-запросы",
        "нагрузка на shard/partition"
      ],
      "expected": [
        "Выполнение < 1мс",
        "eviction/flush сработали",
        "метрики сгенерированы"
      ],
      "tools": [
        "integration test",
        "perf replay",
        "metrics collector"
      ]
    }
  },
  {
    "id": "REQ-1.16",
    "category": "1. Архитектура и Хранилище",
    "title": "Автоматический ребаланс при масштабировании",
    "description": "Автоматический ребаланс при масштабировании должно быть реализовано с учётом высокой производительности, отказоустойчивости и соответствия архитектурным требованиям SAP HANA+.",
    "description_en": "Автоматический ребаланс при масштабировании must be implemented with high performance, fault tolerance and SAP HANA+ grade compliance.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "1.16"
    ],
    "code_module": "src/storage.c",
    "responsible_roles": [
      "storage_architect",
      "performance_engineer"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверить реализацию 'Автоматический ребаланс при масштабировании' на соответствие in-memory архитектуре",
      "input": [
        "Конфигурация",
        "SQL-запросы",
        "нагрузка на shard/partition"
      ],
      "expected": [
        "Выполнение < 1мс",
        "eviction/flush сработали",
        "метрики сгенерированы"
      ],
      "tools": [
        "integration test",
        "perf replay",
        "metrics collector"
      ]
    }
  },
  {
    "id": "REQ-1.17",
    "category": "1. Архитектура и Хранилище",
    "title": "Интеграция слоёв хранения с WAL и snapshot",
    "description": "Интеграция слоёв хранения с WAL и snapshot должно быть реализовано с учётом высокой производительности, отказоустойчивости и соответствия архитектурным требованиям SAP HANA+.",
    "description_en": "Интеграция слоёв хранения с WAL и snapshot must be implemented with high performance, fault tolerance and SAP HANA+ grade compliance.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "1.17"
    ],
    "code_module": "src/storage.c",
    "responsible_roles": [
      "storage_architect",
      "performance_engineer"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверить реализацию 'Интеграция слоёв хранения с WAL и snapshot' на соответствие in-memory архитектуре",
      "input": [
        "Конфигурация",
        "SQL-запросы",
        "нагрузка на shard/partition"
      ],
      "expected": [
        "Выполнение < 1мс",
        "eviction/flush сработали",
        "метрики сгенерированы"
      ],
      "tools": [
        "integration test",
        "perf replay",
        "metrics collector"
      ]
    }
  },
  {
    "id": "REQ-2.1",
    "category": "2. Транзакции и Надёжность",
    "title": "Полный MVCC (compressed chains) + snapshot isolation",
    "description": "Полный MVCC (compressed chains) + snapshot isolation должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "Полный MVCC (compressed chains) + snapshot isolation must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.1"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: Полный MVCC (compressed chains) + snapshot isolation",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-2.2",
    "category": "2. Транзакции и Надёжность",
    "title": "ACID-совместимость + serializable fallback",
    "description": "ACID-совместимость + serializable fallback должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "ACID-совместимость + serializable fallback must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.2"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: ACID-совместимость + serializable fallback",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-2.3",
    "category": "2. Транзакции и Надёжность",
    "title": "WAL + Snapshot + Recovery: instant crash recovery",
    "description": "WAL + Snapshot + Recovery: instant crash recovery должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "WAL + Snapshot + Recovery: instant crash recovery must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.3"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: WAL + Snapshot + Recovery: instant crash recovery",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-2.4",
    "category": "2. Транзакции и Надёжность",
    "title": "Уровни изоляции: RC, RR, SI, SERIALIZABLE",
    "description": "Уровни изоляции: RC, RR, SI, SERIALIZABLE должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "Уровни изоляции: RC, RR, SI, SERIALIZABLE must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.4"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: Уровни изоляции: RC, RR, SI, SERIALIZABLE",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-2.5",
    "category": "2. Транзакции и Надёжность",
    "title": "Фоновая garbage collection (vacuum)",
    "description": "Фоновая garbage collection (vacuum) должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "Фоновая garbage collection (vacuum) must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.5"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: Фоновая garbage collection (vacuum)",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-2.6",
    "category": "2. Транзакции и Надёжность",
    "title": "Failover, watchdog, multi-node recovery",
    "description": "Failover, watchdog, multi-node recovery должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "Failover, watchdog, multi-node recovery must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.6"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: Failover, watchdog, multi-node recovery",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-2.7",
    "category": "2. Транзакции и Надёжность",
    "title": "Поддержка active-active / active-passive репликации",
    "description": "Поддержка active-active / active-passive репликации должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "Поддержка active-active / active-passive репликации must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.7"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: Поддержка active-active / active-passive репликации",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-2.8",
    "category": "2. Транзакции и Надёжность",
    "title": "Консенсусный протокол (Raft/Paxos)",
    "description": "Консенсусный протокол (Raft/Paxos) должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "Консенсусный протокол (Raft/Paxos) must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.8"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: Консенсусный протокол (Raft/Paxos)",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-2.9",
    "category": "2. Транзакции и Надёжность",
    "title": "WAL log compaction и diff-based snapshot",
    "description": "WAL log compaction и diff-based snapshot должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "WAL log compaction и diff-based snapshot must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.9"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: WAL log compaction и diff-based snapshot",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-2.10",
    "category": "2. Транзакции и Надёжность",
    "title": "Parallel WAL writers с flush acknowledgment",
    "description": "Parallel WAL writers с flush acknowledgment должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "Parallel WAL writers с flush acknowledgment must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.10"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: Parallel WAL writers с flush acknowledgment",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-2.11",
    "category": "2. Транзакции и Надёжность",
    "title": "Automatic snapshot rotation и retention",
    "description": "Automatic snapshot rotation и retention должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "Automatic snapshot rotation и retention must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.11"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: Automatic snapshot rotation и retention",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-2.12",
    "category": "2. Транзакции и Надёжность",
    "title": "Recovery consistency across shards and nodes",
    "description": "Recovery consistency across shards and nodes должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "Recovery consistency across shards and nodes must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.12"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: Recovery consistency across shards and nodes",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-2.13",
    "category": "2. Транзакции и Надёжность",
    "title": "Read-your-own-writes и Monotonic reads на уровне сессии",
    "description": "Read-your-own-writes и Monotonic reads на уровне сессии должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "Read-your-own-writes и Monotonic reads на уровне сессии must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.13"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: Read-your-own-writes и Monotonic reads на уровне сессии",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-2.14",
    "category": "2. Транзакции и Надёжность",
    "title": "Detection and resolution of write-write conflicts",
    "description": "Detection and resolution of write-write conflicts должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "Detection and resolution of write-write conflicts must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.14"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: Detection and resolution of write-write conflicts",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-2.15",
    "category": "2. Транзакции и Надёжность",
    "title": "Configurable transaction timeouts and kill semantics",
    "description": "Configurable transaction timeouts and kill semantics должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "Configurable transaction timeouts and kill semantics must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.15"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: Configurable transaction timeouts and kill semantics",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-2.16",
    "category": "2. Транзакции и Надёжность",
    "title": "Concurrent snapshot isolation (multi-version readers)",
    "description": "Concurrent snapshot isolation (multi-version readers) должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "Concurrent snapshot isolation (multi-version readers) must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.16"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: Concurrent snapshot isolation (multi-version readers)",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-2.17",
    "category": "2. Транзакции и Надёжность",
    "title": "Zero-copy snapshot cloning",
    "description": "Zero-copy snapshot cloning должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "Zero-copy snapshot cloning must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.17"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: Zero-copy snapshot cloning",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-2.18",
    "category": "2. Транзакции и Надёжность",
    "title": "WAL-based logical replication (changefeeds)",
    "description": "WAL-based logical replication (changefeeds) должно быть реализовано для обеспечения согласованности, отказоустойчивости и согласованного восстановления на уровне транзакций и кластера.",
    "description_en": "WAL-based logical replication (changefeeds) must be implemented to ensure consistency, fault tolerance, and reliable recovery at both transaction and cluster levels.",
    "test_type": "soak",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "2.18"
    ],
    "code_module": "src/tx.c",
    "responsible_roles": [
      "transaction_engineer",
      "ha_engineer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка механизма: WAL-based logical replication (changefeeds)",
      "input": [
        "многопоточность",
        "параллельные транзакции",
        "ошибки / SIGKILL"
      ],
      "expected": [
        "данные консистентны",
        "снапшот валиден",
        "recovery успешен"
      ],
      "tools": [
        "transactional test harness",
        "wal simulator",
        "crash recovery tool"
      ]
    }
  },
  {
    "id": "REQ-3.1",
    "category": "3. SQL и Языки",
    "title": "Поддержка ANSI SQL:2011+ с оконными функциями, CTE, MERGE",
    "description": "Поддержка ANSI SQL:2011+ с оконными функциями, CTE, MERGE реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Поддержка ANSI SQL:2011+ с оконными функциями, CTE, MERGE must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.1"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Поддержка ANSI SQL:2011+ с оконными функциями, CTE, MERGE",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.2",
    "category": "3. SQL и Языки",
    "title": "Расширения SQL: FILTER, MATCH_RECOGNIZE, JSON функции",
    "description": "Расширения SQL: FILTER, MATCH_RECOGNIZE, JSON функции реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Расширения SQL: FILTER, MATCH_RECOGNIZE, JSON функции must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.2"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Расширения SQL: FILTER, MATCH_RECOGNIZE, JSON функции",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.3",
    "category": "3. SQL и Языки",
    "title": "Cost-based оптимизатор: NDV, histograms, selectivity, cardinality",
    "description": "Cost-based оптимизатор: NDV, histograms, selectivity, cardinality реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Cost-based оптимизатор: NDV, histograms, selectivity, cardinality must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.3"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Cost-based оптимизатор: NDV, histograms, selectivity, cardinality",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.4",
    "category": "3. SQL и Языки",
    "title": "Rule-based оптимизатор: pushdown, projection pruning, simplification",
    "description": "Rule-based оптимизатор: pushdown, projection pruning, simplification реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Rule-based оптимизатор: pushdown, projection pruning, simplification must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.4"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Rule-based оптимизатор: pushdown, projection pruning, simplification",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.5",
    "category": "3. SQL и Языки",
    "title": "Adaptive оптимизация: feedback loops, re-optimization",
    "description": "Adaptive оптимизация: feedback loops, re-optimization реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Adaptive оптимизация: feedback loops, re-optimization must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.5"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Adaptive оптимизация: feedback loops, re-optimization",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.6",
    "category": "3. SQL и Языки",
    "title": "Расширяемый парсер SQL с поддержкой кастомных токенов",
    "description": "Расширяемый парсер SQL с поддержкой кастомных токенов реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Расширяемый парсер SQL с поддержкой кастомных токенов must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.6"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Расширяемый парсер SQL с поддержкой кастомных токенов",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.7",
    "category": "3. SQL и Языки",
    "title": "Встроенный DSL для транзакций (в стиле ABAP/PL/SQL)",
    "description": "Встроенный DSL для транзакций (в стиле ABAP/PL/SQL) реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Встроенный DSL для транзакций (в стиле ABAP/PL/SQL) must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.7"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Встроенный DSL для транзакций (в стиле ABAP/PL/SQL)",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.8",
    "category": "3. SQL и Языки",
    "title": "Поддержка UDF / UDAF: Lua, WASM, JS, C/C++ (sandbox)",
    "description": "Поддержка UDF / UDAF: Lua, WASM, JS, C/C++ (sandbox) реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Поддержка UDF / UDAF: Lua, WASM, JS, C/C++ (sandbox) must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.8"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Поддержка UDF / UDAF: Lua, WASM, JS, C/C++ (sandbox)",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.9",
    "category": "3. SQL и Языки",
    "title": "PL/SQL-подобный язык: процедуры, триггеры, exec hooks",
    "description": "PL/SQL-подобный язык: процедуры, триггеры, exec hooks реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "PL/SQL-подобный язык: процедуры, триггеры, exec hooks must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.9"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: PL/SQL-подобный язык: процедуры, триггеры, exec hooks",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.10",
    "category": "3. SQL и Языки",
    "title": "Встроенные процедуры: временные окна, кластеризация, ML",
    "description": "Встроенные процедуры: временные окна, кластеризация, ML реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Встроенные процедуры: временные окна, кластеризация, ML must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.10"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Встроенные процедуры: временные окна, кластеризация, ML",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.11",
    "category": "3. SQL и Языки",
    "title": "LATERAL, TABLE(), UNNEST в FROM-выражениях",
    "description": "LATERAL, TABLE(), UNNEST в FROM-выражениях реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "LATERAL, TABLE(), UNNEST в FROM-выражениях must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.11"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: LATERAL, TABLE(), UNNEST в FROM-выражениях",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.12",
    "category": "3. SQL и Языки",
    "title": "Обработка структурированных и JSON-объектов в SQL",
    "description": "Обработка структурированных и JSON-объектов в SQL реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Обработка структурированных и JSON-объектов в SQL must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.12"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Обработка структурированных и JSON-объектов в SQL",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.13",
    "category": "3. SQL и Языки",
    "title": "Метаданные SQL и SHOW-команды: SHOW TABLES, SHOW STATS",
    "description": "Метаданные SQL и SHOW-команды: SHOW TABLES, SHOW STATS реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Метаданные SQL и SHOW-команды: SHOW TABLES, SHOW STATS must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.13"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Метаданные SQL и SHOW-команды: SHOW TABLES, SHOW STATS",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.14",
    "category": "3. SQL и Языки",
    "title": "Анализ объяснений EXPLAIN / PLAN / TRACE",
    "description": "Анализ объяснений EXPLAIN / PLAN / TRACE реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Анализ объяснений EXPLAIN / PLAN / TRACE must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.14"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Анализ объяснений EXPLAIN / PLAN / TRACE",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.15",
    "category": "3. SQL и Языки",
    "title": "Контроль синтаксиса, циклов, типов в AST SQL",
    "description": "Контроль синтаксиса, циклов, типов в AST SQL реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Контроль синтаксиса, циклов, типов в AST SQL must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.15"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Контроль синтаксиса, циклов, типов в AST SQL",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.16",
    "category": "3. SQL и Языки",
    "title": "Парсинг и валидация процедур до уровня вызова UDF",
    "description": "Парсинг и валидация процедур до уровня вызова UDF реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Парсинг и валидация процедур до уровня вызова UDF must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.16"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Парсинг и валидация процедур до уровня вызова UDF",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.17",
    "category": "3. SQL и Языки",
    "title": "Интеграция SQL с event engine и external triggers",
    "description": "Интеграция SQL с event engine и external triggers реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Интеграция SQL с event engine и external triggers must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.17"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Интеграция SQL с event engine и external triggers",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.18",
    "category": "3. SQL и Языки",
    "title": "Поддержка MERGE ON multiple columns / fallback logic",
    "description": "Поддержка MERGE ON multiple columns / fallback logic реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Поддержка MERGE ON multiple columns / fallback logic must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.18"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Поддержка MERGE ON multiple columns / fallback logic",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.19",
    "category": "3. SQL и Языки",
    "title": "Сжатие SQL-плана и inline execution моделей",
    "description": "Сжатие SQL-плана и inline execution моделей реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Сжатие SQL-плана и inline execution моделей must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.19"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Сжатие SQL-плана и inline execution моделей",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-3.20",
    "category": "3. SQL и Языки",
    "title": "Инкрементальные обновления в materialized views",
    "description": "Инкрементальные обновления в materialized views реализуется в SQL-движке и DSL-интерпретаторе и должно соответствовать расширяемым, гибким и стандартам SAP HANA+.",
    "description_en": "Инкрементальные обновления в materialized views must be implemented in SQL engine and DSL runtime and follow extensibility and enterprise-grade SQL standards.",
    "test_type": "unit",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "3.20"
    ],
    "code_module": "src/sql.c",
    "responsible_roles": [
      "sql_engineer",
      "query_optimizer",
      "dsl_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Валидация реализации: Инкрементальные обновления в materialized views",
      "input": [
        "SQL-запросы",
        "вложенные конструкции",
        "ошибочные сценарии"
      ],
      "expected": [
        "успешный парсинг",
        "корректный план",
        "точные результаты"
      ],
      "tools": [
        "sql parser test",
        "plan visualizer",
        "execution tracer"
      ]
    }
  },
  {
    "id": "REQ-4.1",
    "category": "4. Интерфейсы и Интеграции",
    "title": "Поддержка JDBC, ODBC, CLI, gRPC, WebSocket, REST, GraphQL, OpenAPI",
    "description": "Поддержка JDBC, ODBC, CLI, gRPC, WebSocket, REST, GraphQL, OpenAPI обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "Поддержка JDBC, ODBC, CLI, gRPC, WebSocket, REST, GraphQL, OpenAPI enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.1"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: Поддержка JDBC, ODBC, CLI, gRPC, WebSocket, REST, GraphQL, OpenAPI",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.2",
    "category": "4. Интерфейсы и Интеграции",
    "title": "CDC и стриминг: Kafka, Pulsar, Debezium, Redis Streams, Changefeed",
    "description": "CDC и стриминг: Kafka, Pulsar, Debezium, Redis Streams, Changefeed обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "CDC и стриминг: Kafka, Pulsar, Debezium, Redis Streams, Changefeed enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.2"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: CDC и стриминг: Kafka, Pulsar, Debezium, Redis Streams, Changefeed",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.3",
    "category": "4. Интерфейсы и Интеграции",
    "title": "Batch ingest: CSV, Excel, Parquet, JSON, XML, S3",
    "description": "Batch ingest: CSV, Excel, Parquet, JSON, XML, S3 обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "Batch ingest: CSV, Excel, Parquet, JSON, XML, S3 enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.3"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: Batch ingest: CSV, Excel, Parquet, JSON, XML, S3",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.4",
    "category": "4. Интерфейсы и Интеграции",
    "title": "Поддержка Webhook и внешних процедур",
    "description": "Поддержка Webhook и внешних процедур обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "Поддержка Webhook и внешних процедур enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.4"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: Поддержка Webhook и внешних процедур",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.5",
    "category": "4. Интерфейсы и Интеграции",
    "title": "Асинхронные процессоры событий (event processors)",
    "description": "Асинхронные процессоры событий (event processors) обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "Асинхронные процессоры событий (event processors) enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.5"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: Асинхронные процессоры событий (event processors)",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.6",
    "category": "4. Интерфейсы и Интеграции",
    "title": "Интеграция с ERP/BI системами и BPMN workflow",
    "description": "Интеграция с ERP/BI системами и BPMN workflow обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "Интеграция с ERP/BI системами и BPMN workflow enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.6"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: Интеграция с ERP/BI системами и BPMN workflow",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.7",
    "category": "4. Интерфейсы и Интеграции",
    "title": "UDF/DSL сценарии обработки потоков",
    "description": "UDF/DSL сценарии обработки потоков обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "UDF/DSL сценарии обработки потоков enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.7"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: UDF/DSL сценарии обработки потоков",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.8",
    "category": "4. Интерфейсы и Интеграции",
    "title": "Поддержка форматного автодетекта и schema inference",
    "description": "Поддержка форматного автодетекта и schema inference обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "Поддержка форматного автодетекта и schema inference enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.8"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: Поддержка форматного автодетекта и schema inference",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.9",
    "category": "4. Интерфейсы и Интеграции",
    "title": "Query rewrite и фильтрация при ingest/stream",
    "description": "Query rewrite и фильтрация при ingest/stream обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "Query rewrite и фильтрация при ingest/stream enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.9"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: Query rewrite и фильтрация при ingest/stream",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.10",
    "category": "4. Интерфейсы и Интеграции",
    "title": "Интеграция с Spark, Flink, NiFi и ETL-движками",
    "description": "Интеграция с Spark, Flink, NiFi и ETL-движками обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "Интеграция с Spark, Flink, NiFi и ETL-движками enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.10"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: Интеграция с Spark, Flink, NiFi и ETL-движками",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.11",
    "category": "4. Интерфейсы и Интеграции",
    "title": "GraphQL auto-schema по SQL-модели",
    "description": "GraphQL auto-schema по SQL-модели обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "GraphQL auto-schema по SQL-модели enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.11"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: GraphQL auto-schema по SQL-модели",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.12",
    "category": "4. Интерфейсы и Интеграции",
    "title": "REST API версионирование и backward-совместимость",
    "description": "REST API версионирование и backward-совместимость обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "REST API версионирование и backward-совместимость enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.12"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: REST API версионирование и backward-совместимость",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.13",
    "category": "4. Интерфейсы и Интеграции",
    "title": "Поддержка JSON:API и HAL форматов",
    "description": "Поддержка JSON:API и HAL форматов обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "Поддержка JSON:API и HAL форматов enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.13"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: Поддержка JSON:API и HAL форматов",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.14",
    "category": "4. Интерфейсы и Интеграции",
    "title": "Поддержка запросов через WebSocket subscription",
    "description": "Поддержка запросов через WebSocket subscription обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "Поддержка запросов через WebSocket subscription enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.14"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: Поддержка запросов через WebSocket subscription",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.15",
    "category": "4. Интерфейсы и Интеграции",
    "title": "Интерфейсы на базе protobuf + Flatbuffers",
    "description": "Интерфейсы на базе protobuf + Flatbuffers обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "Интерфейсы на базе protobuf + Flatbuffers enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.15"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: Интерфейсы на базе protobuf + Flatbuffers",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.16",
    "category": "4. Интерфейсы и Интеграции",
    "title": "Интеграция auth/token-based запросов с интерфейсами",
    "description": "Интеграция auth/token-based запросов с интерфейсами обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "Интеграция auth/token-based запросов с интерфейсами enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.16"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: Интеграция auth/token-based запросов с интерфейсами",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.17",
    "category": "4. Интерфейсы и Интеграции",
    "title": "Ingest queue с лимитами и приоритетами",
    "description": "Ingest queue с лимитами и приоритетами обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "Ingest queue с лимитами и приоритетами enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.17"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: Ingest queue с лимитами и приоритетами",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.18",
    "category": "4. Интерфейсы и Интеграции",
    "title": "Callback-цепочки и reply-to механизмы",
    "description": "Callback-цепочки и reply-to механизмы обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "Callback-цепочки и reply-to механизмы enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.18"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: Callback-цепочки и reply-to механизмы",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.19",
    "category": "4. Интерфейсы и Интеграции",
    "title": "Профилирование endpoint latency в gRPC/REST",
    "description": "Профилирование endpoint latency в gRPC/REST обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "Профилирование endpoint latency в gRPC/REST enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.19"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: Профилирование endpoint latency в gRPC/REST",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-4.20",
    "category": "4. Интерфейсы и Интеграции",
    "title": "Фильтрация входящего потока (row-level predicate pushdown)",
    "description": "Фильтрация входящего потока (row-level predicate pushdown) обеспечивает универсальный доступ к данным, интеграцию и стриминг. Реализация должна учитывать производительность, стандарты совместимости и безопасность.",
    "description_en": "Фильтрация входящего потока (row-level predicate pushdown) enables universal data access, streaming, and integration. Implementation must focus on performance, standards compliance and security.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "4.20"
    ],
    "code_module": "src/net.c",
    "responsible_roles": [
      "integration_engineer",
      "api_architect"
    ],
    "perf_budget_ns": {
      "init": 2500000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверить реализацию интерфейса: Фильтрация входящего потока (row-level predicate pushdown)",
      "input": [
        "внешние клиенты",
        "нагрузочные JSON/CSV/GraphQL запросы"
      ],
      "expected": [
        "доступ работает",
        "latency < 10мс",
        "данные точны"
      ],
      "tools": [
        "grpcurl",
        "rest-tester",
        "stream sim tool"
      ]
    }
  },
  {
    "id": "REQ-5.1",
    "category": "5. BI, ML и OLAP",
    "title": "Поддержка HTAP: смешанные нагрузки, columnar аналитика в OLTP",
    "description": "Поддержка HTAP: смешанные нагрузки, columnar аналитика в OLTP обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "Поддержка HTAP: смешанные нагрузки, columnar аналитика в OLTP is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.1"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: Поддержка HTAP: смешанные нагрузки, columnar аналитика в OLTP",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.2",
    "category": "5. BI, ML и OLAP",
    "title": "Материализованные представления и OLAP кубы",
    "description": "Материализованные представления и OLAP кубы обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "Материализованные представления и OLAP кубы is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.2"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: Материализованные представления и OLAP кубы",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.3",
    "category": "5. BI, ML и OLAP",
    "title": "ROLLUP, CUBE и агрегаты с адаптацией к данным",
    "description": "ROLLUP, CUBE и агрегаты с адаптацией к данным обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "ROLLUP, CUBE и агрегаты с адаптацией к данным is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.3"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: ROLLUP, CUBE и агрегаты с адаптацией к данным",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.4",
    "category": "5. BI, ML и OLAP",
    "title": "Нативная поддержка временных рядов и downsampling",
    "description": "Нативная поддержка временных рядов и downsampling обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "Нативная поддержка временных рядов и downsampling is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.4"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: Нативная поддержка временных рядов и downsampling",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.5",
    "category": "5. BI, ML и OLAP",
    "title": "Функции gap-fill, retention и time-window aggregation",
    "description": "Функции gap-fill, retention и time-window aggregation обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "Функции gap-fill, retention и time-window aggregation is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.5"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: Функции gap-fill, retention и time-window aggregation",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.6",
    "category": "5. BI, ML и OLAP",
    "title": "Поддержка ONNX, TensorFlow, PyTorch моделей",
    "description": "Поддержка ONNX, TensorFlow, PyTorch моделей обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "Поддержка ONNX, TensorFlow, PyTorch моделей is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.6"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: Поддержка ONNX, TensorFlow, PyTorch моделей",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.7",
    "category": "5. BI, ML и OLAP",
    "title": "SQL-инференс моделей в runtime",
    "description": "SQL-инференс моделей в runtime обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "SQL-инференс моделей в runtime is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.7"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: SQL-инференс моделей в runtime",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.8",
    "category": "5. BI, ML и OLAP",
    "title": "Аналитические функции: rank, percentiles, lag/lead",
    "description": "Аналитические функции: rank, percentiles, lag/lead обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "Аналитические функции: rank, percentiles, lag/lead is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.8"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: Аналитические функции: rank, percentiles, lag/lead",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.9",
    "category": "5. BI, ML и OLAP",
    "title": "ML функции: кластеризация, прогнозирование, корреляции",
    "description": "ML функции: кластеризация, прогнозирование, корреляции обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "ML функции: кластеризация, прогнозирование, корреляции is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.9"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: ML функции: кластеризация, прогнозирование, корреляции",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.10",
    "category": "5. BI, ML и OLAP",
    "title": "Инкрементальный update materialized views",
    "description": "Инкрементальный update materialized views обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "Инкрементальный update materialized views is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.10"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: Инкрементальный update materialized views",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.11",
    "category": "5. BI, ML и OLAP",
    "title": "Параллельные агрегаторы с поддержкой vectorization",
    "description": "Параллельные агрегаторы с поддержкой vectorization обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "Параллельные агрегаторы с поддержкой vectorization is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.11"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: Параллельные агрегаторы с поддержкой vectorization",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.12",
    "category": "5. BI, ML и OLAP",
    "title": "Разделение OLTP/OLAP потоков по query-классам",
    "description": "Разделение OLTP/OLAP потоков по query-классам обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "Разделение OLTP/OLAP потоков по query-классам is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.12"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: Разделение OLTP/OLAP потоков по query-классам",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.13",
    "category": "5. BI, ML и OLAP",
    "title": "JIT-компиляция аналитических агрегатов",
    "description": "JIT-компиляция аналитических агрегатов обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "JIT-компиляция аналитических агрегатов is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.13"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: JIT-компиляция аналитических агрегатов",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.14",
    "category": "5. BI, ML и OLAP",
    "title": "Автоматическая генерация summary-таблиц",
    "description": "Автоматическая генерация summary-таблиц обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "Автоматическая генерация summary-таблиц is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.14"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: Автоматическая генерация summary-таблиц",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.15",
    "category": "5. BI, ML и OLAP",
    "title": "Интеграция с BI-движками: Superset, PowerBI, Tableau",
    "description": "Интеграция с BI-движками: Superset, PowerBI, Tableau обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "Интеграция с BI-движками: Superset, PowerBI, Tableau is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.15"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: Интеграция с BI-движками: Superset, PowerBI, Tableau",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.16",
    "category": "5. BI, ML и OLAP",
    "title": "Сжатие и оптимизация columnar кэшей для BI запросов",
    "description": "Сжатие и оптимизация columnar кэшей для BI запросов обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "Сжатие и оптимизация columnar кэшей для BI запросов is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.16"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: Сжатие и оптимизация columnar кэшей для BI запросов",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.17",
    "category": "5. BI, ML и OLAP",
    "title": "Разделение по retention policy и SLA в time series",
    "description": "Разделение по retention policy и SLA в time series обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "Разделение по retention policy и SLA в time series is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.17"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: Разделение по retention policy и SLA в time series",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.18",
    "category": "5. BI, ML и OLAP",
    "title": "Алгоритмы bloom filtering и hyperloglog в агрегациях",
    "description": "Алгоритмы bloom filtering и hyperloglog в агрегациях обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "Алгоритмы bloom filtering и hyperloglog в агрегациях is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.18"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: Алгоритмы bloom filtering и hyperloglog в агрегациях",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.19",
    "category": "5. BI, ML и OLAP",
    "title": "Streaming analytics с autosliding окнами",
    "description": "Streaming analytics с autosliding окнами обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "Streaming analytics с autosliding окнами is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.19"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: Streaming analytics с autosliding окнами",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-5.20",
    "category": "5. BI, ML и OLAP",
    "title": "Realtime KPI агрегация и alert-триггеры",
    "description": "Realtime KPI агрегация и alert-триггеры обеспечивается средствами аналитического ядра, агрегаторов и time series. Требуется поддержка предсказуемой latency и масштабируемой агрегации.",
    "description_en": "Realtime KPI агрегация и alert-триггеры is implemented via analytical core, aggregators and time series engines. Must support predictable latency and scalable aggregation.",
    "test_type": "integration",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "5.20"
    ],
    "code_module": "src/olap.c",
    "responsible_roles": [
      "olap_engineer",
      "ml_engineer",
      "bi_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 2000000
    },
    "test_spec": {
      "goal": "Верификация BI/ML/OLAP механизма: Realtime KPI агрегация и alert-триггеры",
      "input": [
        "большие выборки",
        "временные окна",
        "ML-модель"
      ],
      "expected": [
        "latency < 5мс",
        "модель инференсится",
        "агрегации точны"
      ],
      "tools": [
        "ml test driver",
        "olap benchmark",
        "view tester"
      ]
    }
  },
  {
    "id": "REQ-6.1",
    "category": "6. Безопасность",
    "title": "RBAC / ABAC: роли, атрибуты, row/column-level security",
    "description": "RBAC / ABAC: роли, атрибуты, row/column-level security реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "RBAC / ABAC: роли, атрибуты, row/column-level security must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.1"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: RBAC / ABAC: роли, атрибуты, row/column-level security",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.2",
    "category": "6. Безопасность",
    "title": "TLS / mTLS / JWT: защита соединений, поддержка token-based access",
    "description": "TLS / mTLS / JWT: защита соединений, поддержка token-based access реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "TLS / mTLS / JWT: защита соединений, поддержка token-based access must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.2"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: TLS / mTLS / JWT: защита соединений, поддержка token-based access",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.3",
    "category": "6. Безопасность",
    "title": "TDE и шифрование данных в памяти и на NVMe",
    "description": "TDE и шифрование данных в памяти и на NVMe реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "TDE и шифрование данных в памяти и на NVMe must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.3"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: TDE и шифрование данных в памяти и на NVMe",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.4",
    "category": "6. Безопасность",
    "title": "Forward secrecy и ephemeral key rotation",
    "description": "Forward secrecy и ephemeral key rotation реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "Forward secrecy и ephemeral key rotation must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.4"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: Forward secrecy и ephemeral key rotation",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.5",
    "category": "6. Безопасность",
    "title": "ACL: сетевые правила и scoped access tokens",
    "description": "ACL: сетевые правила и scoped access tokens реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "ACL: сетевые правила и scoped access tokens must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.5"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: ACL: сетевые правила и scoped access tokens",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.6",
    "category": "6. Безопасность",
    "title": "Аудит: DML/DDL, immutable chainable logs",
    "description": "Аудит: DML/DDL, immutable chainable logs реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "Аудит: DML/DDL, immutable chainable logs must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.6"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: Аудит: DML/DDL, immutable chainable logs",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.7",
    "category": "6. Безопасность",
    "title": "Access Policy Engine: predicate-based access control",
    "description": "Access Policy Engine: predicate-based access control реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "Access Policy Engine: predicate-based access control must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.7"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: Access Policy Engine: predicate-based access control",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.8",
    "category": "6. Безопасность",
    "title": "SQL-инъекции: защита, sandbox Lua/WASM",
    "description": "SQL-инъекции: защита, sandbox Lua/WASM реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "SQL-инъекции: защита, sandbox Lua/WASM must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.8"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: SQL-инъекции: защита, sandbox Lua/WASM",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.9",
    "category": "6. Безопасность",
    "title": "Контроль доступа на уровне функций, таблиц, UDF",
    "description": "Контроль доступа на уровне функций, таблиц, UDF реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "Контроль доступа на уровне функций, таблиц, UDF must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.9"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: Контроль доступа на уровне функций, таблиц, UDF",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.10",
    "category": "6. Безопасность",
    "title": "Шифрование конфигураций и переменных окружения",
    "description": "Шифрование конфигураций и переменных окружения реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "Шифрование конфигураций и переменных окружения must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.10"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: Шифрование конфигураций и переменных окружения",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.11",
    "category": "6. Безопасность",
    "title": "Разграничение прав в runtime (на уровне процессов/сессий)",
    "description": "Разграничение прав в runtime (на уровне процессов/сессий) реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "Разграничение прав в runtime (на уровне процессов/сессий) must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.11"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: Разграничение прав в runtime (на уровне процессов/сессий)",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.12",
    "category": "6. Безопасность",
    "title": "Безопасная загрузка расширений, проверка подписей",
    "description": "Безопасная загрузка расширений, проверка подписей реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "Безопасная загрузка расширений, проверка подписей must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.12"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: Безопасная загрузка расширений, проверка подписей",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.13",
    "category": "6. Безопасность",
    "title": "Логика multi-tenant изоляции и шардирования",
    "description": "Логика multi-tenant изоляции и шардирования реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "Логика multi-tenant изоляции и шардирования must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.13"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: Логика multi-tenant изоляции и шардирования",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.14",
    "category": "6. Безопасность",
    "title": "Запрет exec на unsafe-хранимых процедурах",
    "description": "Запрет exec на unsafe-хранимых процедурах реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "Запрет exec на unsafe-хранимых процедурах must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.14"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: Запрет exec на unsafe-хранимых процедурах",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.15",
    "category": "6. Безопасность",
    "title": "Политики времени жизни сессий и ревокация токенов",
    "description": "Политики времени жизни сессий и ревокация токенов реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "Политики времени жизни сессий и ревокация токенов must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.15"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: Политики времени жизни сессий и ревокация токенов",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.16",
    "category": "6. Безопасность",
    "title": "Fail2ban-like механизм для блокировки IP",
    "description": "Fail2ban-like механизм для блокировки IP реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "Fail2ban-like механизм для блокировки IP must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.16"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: Fail2ban-like механизм для блокировки IP",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.17",
    "category": "6. Безопасность",
    "title": "Поддержка audit trigger на уровне таблиц и UDF",
    "description": "Поддержка audit trigger на уровне таблиц и UDF реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "Поддержка audit trigger на уровне таблиц и UDF must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.17"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: Поддержка audit trigger на уровне таблиц и UDF",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.18",
    "category": "6. Безопасность",
    "title": "Иммутабельность логов через chained hash",
    "description": "Иммутабельность логов через chained hash реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "Иммутабельность логов через chained hash must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.18"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: Иммутабельность логов через chained hash",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.19",
    "category": "6. Безопасность",
    "title": "Поддержка экспорта логов в SIEM/ELK",
    "description": "Поддержка экспорта логов в SIEM/ELK реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "Поддержка экспорта логов в SIEM/ELK must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.19"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: Поддержка экспорта логов в SIEM/ELK",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-6.20",
    "category": "6. Безопасность",
    "title": "Безопасный режим startup / recovery с контролем консистентности",
    "description": "Безопасный режим startup / recovery с контролем консистентности реализуется в рамках политики безопасности, обеспечения приватности данных, логирования и контроля доступа. Требуется полное покрытие внутренних и внешних угроз.",
    "description_en": "Безопасный режим startup / recovery с контролем консистентности must be implemented as part of the security policy, data privacy, logging and access control. Must cover internal and external threat vectors.",
    "test_type": "security",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "6.20"
    ],
    "code_module": "src/security.c",
    "responsible_roles": [
      "security_engineer",
      "platform_architect"
    ],
    "perf_budget_ns": {
      "init": 3000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка реализации безопасной логики: Безопасный режим startup / recovery с контролем консистентности",
      "input": [
        "SQL",
        "конфигурации",
        "runtime-параметры",
        "атаки"
      ],
      "expected": [
        "нет уязвимостей",
        "логирование включено",
        "все политики сработали"
      ],
      "tools": [
        "fuzz tester",
        "auth simulator",
        "security audit"
      ]
    }
  },
  {
    "id": "REQ-7.1",
    "category": "7. Observability и DevOps",
    "title": "Поддержка Prometheus, OpenMetrics, метрики latency, IOPS, nanoscale",
    "description": "Поддержка Prometheus, OpenMetrics, метрики latency, IOPS, nanoscale должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Поддержка Prometheus, OpenMetrics, метрики latency, IOPS, nanoscale must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.1"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Поддержка Prometheus, OpenMetrics, метрики latency, IOPS, nanoscale",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.2",
    "category": "7. Observability и DevOps",
    "title": "Трейсинг: OpenTelemetry, Jaeger, Zipkin, perf-интеграция",
    "description": "Трейсинг: OpenTelemetry, Jaeger, Zipkin, perf-интеграция должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Трейсинг: OpenTelemetry, Jaeger, Zipkin, perf-интеграция must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.2"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Трейсинг: OpenTelemetry, Jaeger, Zipkin, perf-интеграция",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.3",
    "category": "7. Observability и DevOps",
    "title": "Query Tracing, span-level и pipeline stage профилирование",
    "description": "Query Tracing, span-level и pipeline stage профилирование должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Query Tracing, span-level и pipeline stage профилирование must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.3"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Query Tracing, span-level и pipeline stage профилирование",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.4",
    "category": "7. Observability и DevOps",
    "title": "Flamegraph и execution timeline профилировщик",
    "description": "Flamegraph и execution timeline профилировщик должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Flamegraph и execution timeline профилировщик must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.4"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Flamegraph и execution timeline профилировщик",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.5",
    "category": "7. Observability и DevOps",
    "title": "Structured logging: stderr, syslog, JSON, binary",
    "description": "Structured logging: stderr, syslog, JSON, binary должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Structured logging: stderr, syslog, JSON, binary must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.5"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Structured logging: stderr, syslog, JSON, binary",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.6",
    "category": "7. Observability и DevOps",
    "title": "Fuzzing: libFuzzer, AFL++, ASAN/TSAN/MSAN",
    "description": "Fuzzing: libFuzzer, AFL++, ASAN/TSAN/MSAN должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Fuzzing: libFuzzer, AFL++, ASAN/TSAN/MSAN must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.6"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Fuzzing: libFuzzer, AFL++, ASAN/TSAN/MSAN",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.7",
    "category": "7. Observability и DevOps",
    "title": "Fault injection и chaos testing",
    "description": "Fault injection и chaos testing должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Fault injection и chaos testing must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.7"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Fault injection и chaos testing",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.8",
    "category": "7. Observability и DevOps",
    "title": "Crash recovery тесты и восстановление WAL/Snapshot",
    "description": "Crash recovery тесты и восстановление WAL/Snapshot должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Crash recovery тесты и восстановление WAL/Snapshot must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.8"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Crash recovery тесты и восстановление WAL/Snapshot",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.9",
    "category": "7. Observability и DevOps",
    "title": "CI/CD интеграция: GitHub Actions, Ninja, mutation testing",
    "description": "CI/CD интеграция: GitHub Actions, Ninja, mutation testing должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "CI/CD интеграция: GitHub Actions, Ninja, mutation testing must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.9"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: CI/CD интеграция: GitHub Actions, Ninja, mutation testing",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.10",
    "category": "7. Observability и DevOps",
    "title": "Поддержка покрытий: coverage, mutation, soak, stress",
    "description": "Поддержка покрытий: coverage, mutation, soak, stress должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Поддержка покрытий: coverage, mutation, soak, stress must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.10"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Поддержка покрытий: coverage, mutation, soak, stress",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.11",
    "category": "7. Observability и DevOps",
    "title": "Schema evolution: online ALTER, rollback, live reload",
    "description": "Schema evolution: online ALTER, rollback, live reload должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Schema evolution: online ALTER, rollback, live reload must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.11"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Schema evolution: online ALTER, rollback, live reload",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.12",
    "category": "7. Observability и DevOps",
    "title": "Test hooks в SQL-процедурах и runtime API",
    "description": "Test hooks в SQL-процедурах и runtime API должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Test hooks в SQL-процедурах и runtime API must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.12"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Test hooks в SQL-процедурах и runtime API",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.13",
    "category": "7. Observability и DevOps",
    "title": "Alertmanager: SLA breach и перформанс триггеры",
    "description": "Alertmanager: SLA breach и перформанс триггеры должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Alertmanager: SLA breach и перформанс триггеры must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.13"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Alertmanager: SLA breach и перформанс триггеры",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.14",
    "category": "7. Observability и DevOps",
    "title": "Автоматическая регистрация и отписка метрик",
    "description": "Автоматическая регистрация и отписка метрик должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Автоматическая регистрация и отписка метрик must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.14"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Автоматическая регистрация и отписка метрик",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.15",
    "category": "7. Observability и DevOps",
    "title": "Автоанализ медленных запросов и write amplification",
    "description": "Автоанализ медленных запросов и write amplification должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Автоанализ медленных запросов и write amplification must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.15"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Автоанализ медленных запросов и write amplification",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.16",
    "category": "7. Observability и DevOps",
    "title": "Контроль прогрева кешей и memory prefetch",
    "description": "Контроль прогрева кешей и memory prefetch должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Контроль прогрева кешей и memory prefetch must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.16"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Контроль прогрева кешей и memory prefetch",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.17",
    "category": "7. Observability и DevOps",
    "title": "Контроль версий и audit trail DDL-изменений",
    "description": "Контроль версий и audit trail DDL-изменений должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Контроль версий и audit trail DDL-изменений must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.17"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Контроль версий и audit trail DDL-изменений",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.18",
    "category": "7. Observability и DevOps",
    "title": "Поддержка unit/integration/fuzz сценариев через CLI",
    "description": "Поддержка unit/integration/fuzz сценариев через CLI должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Поддержка unit/integration/fuzz сценариев через CLI must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.18"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Поддержка unit/integration/fuzz сценариев через CLI",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.19",
    "category": "7. Observability и DevOps",
    "title": "Автофикс нарушений SLA и rollback в safe-зону",
    "description": "Автофикс нарушений SLA и rollback в safe-зону должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Автофикс нарушений SLA и rollback в safe-зону must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.19"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Автофикс нарушений SLA и rollback в safe-зону",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-7.20",
    "category": "7. Observability и DevOps",
    "title": "Graph-интерфейс зависимостей между компонентами",
    "description": "Graph-интерфейс зависимостей между компонентами должны обеспечивать полную прозрачность выполнения, мониторинг, тестируемость и непрерывную поставку изменений.",
    "description_en": "Graph-интерфейс зависимостей между компонентами must provide full observability, monitoring, testability, and continuous delivery of changes.",
    "test_type": "observability",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "7.20"
    ],
    "code_module": "src/metrics.c",
    "responsible_roles": [
      "devops_engineer",
      "observability_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка: Graph-интерфейс зависимостей между компонентами",
      "input": [
        "нагрузка",
        "трейсинг",
        "SQL-запросы",
        "отказ"
      ],
      "expected": [
        "метрики и логи собраны",
        "trace отображается",
        "автооткат работает"
      ],
      "tools": [
        "prometheus",
        "otel",
        "chaos monkey",
        "mutation checker"
      ]
    }
  },
  {
    "id": "REQ-8.1",
    "category": "8. Производительность",
    "title": "Latency OLTP < 1 мс, критические запросы < 500 нс",
    "description": "Latency OLTP < 1 мс, критические запросы < 500 нс реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Latency OLTP < 1 мс, критические запросы < 500 нс must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.1"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Latency OLTP < 1 мс, критические запросы < 500 нс",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.2",
    "category": "8. Производительность",
    "title": "Поддержка 20M+ транзакций/день, 9M записей в день / филиал",
    "description": "Поддержка 20M+ транзакций/день, 9M записей в день / филиал реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Поддержка 20M+ транзакций/день, 9M записей в день / филиал must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.2"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Поддержка 20M+ транзакций/день, 9M записей в день / филиал",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.3",
    "category": "8. Производительность",
    "title": "Vectorized execution, parallel pipelines, streaming aggregator",
    "description": "Vectorized execution, parallel pipelines, streaming aggregator реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Vectorized execution, parallel pipelines, streaming aggregator must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.3"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Vectorized execution, parallel pipelines, streaming aggregator",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.4",
    "category": "8. Производительность",
    "title": "Adaptive joins: hash, merge, index-nested loop, grace hash",
    "description": "Adaptive joins: hash, merge, index-nested loop, grace hash реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Adaptive joins: hash, merge, index-nested loop, grace hash must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.4"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Adaptive joins: hash, merge, index-nested loop, grace hash",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.5",
    "category": "8. Производительность",
    "title": "Runtime re-optimization, plan caching, selectivity feedback",
    "description": "Runtime re-optimization, plan caching, selectivity feedback реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Runtime re-optimization, plan caching, selectivity feedback must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.5"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Runtime re-optimization, plan caching, selectivity feedback",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.6",
    "category": "8. Производительность",
    "title": "PAX / Apache Arrow layouts, format-aware execution",
    "description": "PAX / Apache Arrow layouts, format-aware execution реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "PAX / Apache Arrow layouts, format-aware execution must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.6"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: PAX / Apache Arrow layouts, format-aware execution",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.7",
    "category": "8. Производительность",
    "title": "Copy-on-write snapshots, instant backup/restore, clone tables",
    "description": "Copy-on-write snapshots, instant backup/restore, clone tables реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Copy-on-write snapshots, instant backup/restore, clone tables must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.7"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Copy-on-write snapshots, instant backup/restore, clone tables",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.8",
    "category": "8. Производительность",
    "title": "Support for large memory models and NUMA-aware caching",
    "description": "Support for large memory models and NUMA-aware caching реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Support for large memory models and NUMA-aware caching must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.8"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Support for large memory models and NUMA-aware caching",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.9",
    "category": "8. Производительность",
    "title": "Column-store execution acceleration via SIMD",
    "description": "Column-store execution acceleration via SIMD реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Column-store execution acceleration via SIMD must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.9"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Column-store execution acceleration via SIMD",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.10",
    "category": "8. Производительность",
    "title": "Hot path optimization and pipeline fusion",
    "description": "Hot path optimization and pipeline fusion реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Hot path optimization and pipeline fusion must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.10"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Hot path optimization and pipeline fusion",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.11",
    "category": "8. Производительность",
    "title": "Hybrid workload scheduler: OLTP/OLAP auto-switch",
    "description": "Hybrid workload scheduler: OLTP/OLAP auto-switch реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Hybrid workload scheduler: OLTP/OLAP auto-switch must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.11"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Hybrid workload scheduler: OLTP/OLAP auto-switch",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.12",
    "category": "8. Производительность",
    "title": "Prefetching engine with cache coloring strategy",
    "description": "Prefetching engine with cache coloring strategy реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Prefetching engine with cache coloring strategy must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.12"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Prefetching engine with cache coloring strategy",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.13",
    "category": "8. Производительность",
    "title": "Microsecond-level yield and contention detection",
    "description": "Microsecond-level yield and contention detection реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Microsecond-level yield and contention detection must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.13"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Microsecond-level yield and contention detection",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.14",
    "category": "8. Производительность",
    "title": "Join flattening and projection pruning at plan phase",
    "description": "Join flattening and projection pruning at plan phase реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Join flattening and projection pruning at plan phase must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.14"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Join flattening and projection pruning at plan phase",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.15",
    "category": "8. Производительность",
    "title": "Execution budget enforcement (per-query)",
    "description": "Execution budget enforcement (per-query) реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Execution budget enforcement (per-query) must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.15"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Execution budget enforcement (per-query)",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.16",
    "category": "8. Производительность",
    "title": "Compiled plan caching with fast invalidation",
    "description": "Compiled plan caching with fast invalidation реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Compiled plan caching with fast invalidation must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.16"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Compiled plan caching with fast invalidation",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.17",
    "category": "8. Производительность",
    "title": "Asynchronous I/O with batching and zero-copy paths",
    "description": "Asynchronous I/O with batching and zero-copy paths реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Asynchronous I/O with batching and zero-copy paths must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.17"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Asynchronous I/O with batching and zero-copy paths",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.18",
    "category": "8. Производительность",
    "title": "Instant result materialization for small resultsets",
    "description": "Instant result materialization for small resultsets реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Instant result materialization for small resultsets must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.18"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Instant result materialization for small resultsets",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.19",
    "category": "8. Производительность",
    "title": "Custom vector functions and fast-path predicates",
    "description": "Custom vector functions and fast-path predicates реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Custom vector functions and fast-path predicates must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.19"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Custom vector functions and fast-path predicates",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-8.20",
    "category": "8. Производительность",
    "title": "Dynamic fanout strategy based on CPU topology",
    "description": "Dynamic fanout strategy based on CPU topology реализуется на уровне ядра исполнения запросов и планировщика. Требуется обеспечить максимальную производительность при минимальной задержке.",
    "description_en": "Dynamic fanout strategy based on CPU topology must be implemented in query execution core and planner. Requires maximum throughput and lowest latency.",
    "test_type": "performance",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "8.20"
    ],
    "code_module": "src/execute.c",
    "responsible_roles": [
      "performance_engineer",
      "runtime_optimizer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 200000
    },
    "test_spec": {
      "goal": "Проверка: Dynamic fanout strategy based on CPU topology",
      "input": [
        "нагрузка 20M txn",
        "long-running queries",
        "concurrency stress"
      ],
      "expected": [
        "latency < SLA",
        "throughput > 99 перцентиль",
        "нет деградации"
      ],
      "tools": [
        "query benchmarker",
        "latency profiler",
        "pipeline heatmap"
      ]
    }
  },
  {
    "id": "REQ-9.1",
    "category": "9. Расширяемость",
    "title": "Поддержка UDF / UDAF / расширений на C/C++, sandbox API",
    "description": "Поддержка UDF / UDAF / расширений на C/C++, sandbox API должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "Поддержка UDF / UDAF / расширений на C/C++, sandbox API must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.1"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: Поддержка UDF / UDAF / расширений на C/C++, sandbox API",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.2",
    "category": "9. Расширяемость",
    "title": "Загрузка внешних модулей: dlopen / LoadLibrary",
    "description": "Загрузка внешних модулей: dlopen / LoadLibrary должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "Загрузка внешних модулей: dlopen / LoadLibrary must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.2"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: Загрузка внешних модулей: dlopen / LoadLibrary",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.3",
    "category": "9. Расширяемость",
    "title": "Собственный бинарный SQL-протокол",
    "description": "Собственный бинарный SQL-протокол должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "Собственный бинарный SQL-протокол must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.3"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: Собственный бинарный SQL-протокол",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.4",
    "category": "9. Расширяемость",
    "title": "Совместимость с PostgreSQL wire protocol",
    "description": "Совместимость с PostgreSQL wire protocol должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "Совместимость с PostgreSQL wire protocol must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.4"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: Совместимость с PostgreSQL wire protocol",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.5",
    "category": "9. Расширяемость",
    "title": "REST, gRPC, JSON:API для UDF/DSL/ETL",
    "description": "REST, gRPC, JSON:API для UDF/DSL/ETL должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "REST, gRPC, JSON:API для UDF/DSL/ETL must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.5"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: REST, gRPC, JSON:API для UDF/DSL/ETL",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.6",
    "category": "9. Расширяемость",
    "title": "Расширяемый планировщик ETL / задач",
    "description": "Расширяемый планировщик ETL / задач должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "Расширяемый планировщик ETL / задач must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.6"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: Расширяемый планировщик ETL / задач",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.7",
    "category": "9. Расширяемость",
    "title": "Генерация UDF/ETL/DSL на лету",
    "description": "Генерация UDF/ETL/DSL на лету должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "Генерация UDF/ETL/DSL на лету must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.7"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: Генерация UDF/ETL/DSL на лету",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.8",
    "category": "9. Расширяемость",
    "title": "Расширения операторов SQL через DSL",
    "description": "Расширения операторов SQL через DSL должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "Расширения операторов SQL через DSL must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.8"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: Расширения операторов SQL через DSL",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.9",
    "category": "9. Расширяемость",
    "title": "Расширяемые агрегаты с fallback логикой",
    "description": "Расширяемые агрегаты с fallback логикой должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "Расширяемые агрегаты с fallback логикой must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.9"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: Расширяемые агрегаты с fallback логикой",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.10",
    "category": "9. Расширяемость",
    "title": "UDF isolation и sandbox constraints",
    "description": "UDF isolation и sandbox constraints должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "UDF isolation и sandbox constraints must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.10"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: UDF isolation и sandbox constraints",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.11",
    "category": "9. Расширяемость",
    "title": "Управление версиями расширений и rollback",
    "description": "Управление версиями расширений и rollback должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "Управление версиями расширений и rollback must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.11"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: Управление версиями расширений и rollback",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.12",
    "category": "9. Расширяемость",
    "title": "Поддержка внешних форматов/коннекторов через плагины",
    "description": "Поддержка внешних форматов/коннекторов через плагины должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "Поддержка внешних форматов/коннекторов через плагины must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.12"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: Поддержка внешних форматов/коннекторов через плагины",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.13",
    "category": "9. Расширяемость",
    "title": "Динамическая регистрация форматов и сериализаторов",
    "description": "Динамическая регистрация форматов и сериализаторов должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "Динамическая регистрация форматов и сериализаторов must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.13"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: Динамическая регистрация форматов и сериализаторов",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.14",
    "category": "9. Расширяемость",
    "title": "Расширяемый парсер с множеством диалектов SQL",
    "description": "Расширяемый парсер с множеством диалектов SQL должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "Расширяемый парсер с множеством диалектов SQL must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.14"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: Расширяемый парсер с множеством диалектов SQL",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.15",
    "category": "9. Расширяемость",
    "title": "Интерфейс регистрации собственных типов данных",
    "description": "Интерфейс регистрации собственных типов данных должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "Интерфейс регистрации собственных типов данных must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.15"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: Интерфейс регистрации собственных типов данных",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.16",
    "category": "9. Расширяемость",
    "title": "Интеграция WASM-модулей в SQL runtime",
    "description": "Интеграция WASM-модулей в SQL runtime должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "Интеграция WASM-модулей в SQL runtime must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.16"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: Интеграция WASM-модулей в SQL runtime",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.17",
    "category": "9. Расширяемость",
    "title": "DSL-язык для хранения и конфигурации расширений",
    "description": "DSL-язык для хранения и конфигурации расширений должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "DSL-язык для хранения и конфигурации расширений must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.17"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: DSL-язык для хранения и конфигурации расширений",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.18",
    "category": "9. Расширяемость",
    "title": "Безопасная проверка и sandbox для расширений",
    "description": "Безопасная проверка и sandbox для расширений должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "Безопасная проверка и sandbox для расширений must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.18"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: Безопасная проверка и sandbox для расширений",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.19",
    "category": "9. Расширяемость",
    "title": "Режимы привилегий для UDF (sandbox/unsafe)",
    "description": "Режимы привилегий для UDF (sandbox/unsafe) должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "Режимы привилегий для UDF (sandbox/unsafe) must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.19"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: Режимы привилегий для UDF (sandbox/unsafe)",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-9.20",
    "category": "9. Расширяемость",
    "title": "Расширения хранимых процедур: event-based",
    "description": "Расширения хранимых процедур: event-based должно быть реализовано с учётом гибкой загрузки, безопасного выполнения и полной совместимости с ядром системы.",
    "description_en": "Расширения хранимых процедур: event-based must support flexible loading, secure execution, and full compatibility with the system core.",
    "test_type": "extension",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "9.20"
    ],
    "code_module": "src/extensions.c",
    "responsible_roles": [
      "extensibility_engineer",
      "udf_sandbox_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 300000
    },
    "test_spec": {
      "goal": "Проверка реализации: Расширения хранимых процедур: event-based",
      "input": [
        "UDF/ETL/DSL скрипты",
        "внешние модули",
        "контроль прав"
      ],
      "expected": [
        "расширения работают",
        "ограничения соблюдены",
        "нет unsafe behavior"
      ],
      "tools": [
        "udf loader",
        "sandbox runner",
        "API validator"
      ]
    }
  },
  {
    "id": "REQ-10.1",
    "category": "10. Тестируемость и структура проекта",
    "title": "Архитектура: Parser → Planner → Optimizer → Executor → Storage",
    "description": "Архитектура: Parser → Planner → Optimizer → Executor → Storage должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Архитектура: Parser → Planner → Optimizer → Executor → Storage must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.1"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Архитектура: Parser → Planner → Optimizer → Executor → Storage",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.2",
    "category": "10. Тестируемость и структура проекта",
    "title": "Структура модулей: core/, tx/, sql/, net/, api/, metrics/, tools/, plugins/",
    "description": "Структура модулей: core/, tx/, sql/, net/, api/, metrics/, tools/, plugins/ должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Структура модулей: core/, tx/, sql/, net/, api/, metrics/, tools/, plugins/ must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.2"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Структура модулей: core/, tx/, sql/, net/, api/, metrics/, tools/, plugins/",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.3",
    "category": "10. Тестируемость и структура проекта",
    "title": "Ограничение модулей ≤ 500 строк, скрытие через *.internal/",
    "description": "Ограничение модулей ≤ 500 строк, скрытие через *.internal/ должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Ограничение модулей ≤ 500 строк, скрытие через *.internal/ must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.3"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Ограничение модулей ≤ 500 строк, скрытие через *.internal/",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.4",
    "category": "10. Тестируемость и структура проекта",
    "title": "Поддержка всех видов тестов: unit, integration, fuzz, stress, soak, mutation",
    "description": "Поддержка всех видов тестов: unit, integration, fuzz, stress, soak, mutation должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Поддержка всех видов тестов: unit, integration, fuzz, stress, soak, mutation must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.4"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Поддержка всех видов тестов: unit, integration, fuzz, stress, soak, mutation",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.5",
    "category": "10. Тестируемость и структура проекта",
    "title": "Поддержка покрытия: line, branch, mutation, condition",
    "description": "Поддержка покрытия: line, branch, mutation, condition должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Поддержка покрытия: line, branch, mutation, condition must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.5"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Поддержка покрытия: line, branch, mutation, condition",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.6",
    "category": "10. Тестируемость и структура проекта",
    "title": "CI/CD-пайплайн с полной проверкой на каждый PR",
    "description": "CI/CD-пайплайн с полной проверкой на каждый PR должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "CI/CD-пайплайн с полной проверкой на каждый PR must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.6"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: CI/CD-пайплайн с полной проверкой на каждый PR",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.7",
    "category": "10. Тестируемость и структура проекта",
    "title": "Поддержка context-based API и opaque структур",
    "description": "Поддержка context-based API и opaque структур должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Поддержка context-based API и opaque структур must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.7"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Поддержка context-based API и opaque структур",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.8",
    "category": "10. Тестируемость и структура проекта",
    "title": "Документация и doxygen по всем public API",
    "description": "Документация и doxygen по всем public API должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Документация и doxygen по всем public API must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.8"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Документация и doxygen по всем public API",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.9",
    "category": "10. Тестируемость и структура проекта",
    "title": "Тесты схем и миграций: онлайн ALTER, rollback, reload",
    "description": "Тесты схем и миграций: онлайн ALTER, rollback, reload должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Тесты схем и миграций: онлайн ALTER, rollback, reload must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.9"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Тесты схем и миграций: онлайн ALTER, rollback, reload",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.10",
    "category": "10. Тестируемость и структура проекта",
    "title": "Стандарты кодирования: snake_case, разделение функций ≤ 40 строк",
    "description": "Стандарты кодирования: snake_case, разделение функций ≤ 40 строк должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Стандарты кодирования: snake_case, разделение функций ≤ 40 строк must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.10"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Стандарты кодирования: snake_case, разделение функций ≤ 40 строк",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.11",
    "category": "10. Тестируемость и структура проекта",
    "title": "Поддержка логирования: log_event(op, time_ns, size)",
    "description": "Поддержка логирования: log_event(op, time_ns, size) должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Поддержка логирования: log_event(op, time_ns, size) must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.11"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Поддержка логирования: log_event(op, time_ns, size)",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.12",
    "category": "10. Тестируемость и структура проекта",
    "title": "Форматы данных: UTF-8, JSON, timestamps, числа",
    "description": "Форматы данных: UTF-8, JSON, timestamps, числа должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Форматы данных: UTF-8, JSON, timestamps, числа must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.12"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Форматы данных: UTF-8, JSON, timestamps, числа",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.13",
    "category": "10. Тестируемость и структура проекта",
    "title": "Семантика: instant rollback, transactional schema ops",
    "description": "Семантика: instant rollback, transactional schema ops должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Семантика: instant rollback, transactional schema ops must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.13"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Семантика: instant rollback, transactional schema ops",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.14",
    "category": "10. Тестируемость и структура проекта",
    "title": "Поддержка dev CLI и REST API для тестирования",
    "description": "Поддержка dev CLI и REST API для тестирования должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Поддержка dev CLI и REST API для тестирования must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.14"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Поддержка dev CLI и REST API для тестирования",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.15",
    "category": "10. Тестируемость и структура проекта",
    "title": "Фреймворк тестирования хранимых процедур",
    "description": "Фреймворк тестирования хранимых процедур должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Фреймворк тестирования хранимых процедур must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.15"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Фреймворк тестирования хранимых процедур",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.16",
    "category": "10. Тестируемость и структура проекта",
    "title": "Фреймворк тестирования распределённых query",
    "description": "Фреймворк тестирования распределённых query должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Фреймворк тестирования распределённых query must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.16"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Фреймворк тестирования распределённых query",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.17",
    "category": "10. Тестируемость и структура проекта",
    "title": "Fuzzing библиотек с AFL++, libFuzzer",
    "description": "Fuzzing библиотек с AFL++, libFuzzer должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Fuzzing библиотек с AFL++, libFuzzer must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.17"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Fuzzing библиотек с AFL++, libFuzzer",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.18",
    "category": "10. Тестируемость и структура проекта",
    "title": "ASAN/TSAN/MSAN при сборке в debug-моде",
    "description": "ASAN/TSAN/MSAN при сборке в debug-моде должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "ASAN/TSAN/MSAN при сборке в debug-моде must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.18"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: ASAN/TSAN/MSAN при сборке в debug-моде",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.19",
    "category": "10. Тестируемость и структура проекта",
    "title": "Инструменты: snapshot comparison, trace visualizer",
    "description": "Инструменты: snapshot comparison, trace visualizer должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Инструменты: snapshot comparison, trace visualizer must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.19"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Инструменты: snapshot comparison, trace visualizer",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-10.20",
    "category": "10. Тестируемость и структура проекта",
    "title": "Mock-фреймворк для API внешних систем и ETL",
    "description": "Mock-фреймворк для API внешних систем и ETL должно быть реализовано с акцентом на прозрачность, изоляцию модулей, автоматизацию и инженерную зрелость кода.",
    "description_en": "Mock-фреймворк для API внешних систем и ETL must support transparency, modular isolation, automation and code engineering maturity.",
    "test_type": "architecture",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "10.20"
    ],
    "code_module": "src/core.c",
    "responsible_roles": [
      "qa_engineer",
      "core_architect",
      "test_infra_engineer"
    ],
    "perf_budget_ns": {
      "init": 500000,
      "runtime": 250000
    },
    "test_spec": {
      "goal": "Проверка архитектурной дисциплины: Mock-фреймворк для API внешних систем и ETL",
      "input": [
        "структура каталогов",
        "код",
        "логика тестов"
      ],
      "expected": [
        "структура соблюдена",
        "покрытие > 95%",
        "автоматизация CI/CD"
      ],
      "tools": [
        "coverage tool",
        "lint checker",
        "mutation engine",
        "fuzz runner"
      ]
    }
  },
  {
    "id": "REQ-11.1",
    "category": "11. Управление схемой",
    "title": "Поддержка SYSTEM VERSIONED таблиц",
    "description": "Поддержка SYSTEM VERSIONED таблиц обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "Поддержка SYSTEM VERSIONED таблиц provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.1"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: Поддержка SYSTEM VERSIONED таблиц",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.2",
    "category": "11. Управление схемой",
    "title": "Поддержка AS OF запросов и snapshot-версий",
    "description": "Поддержка AS OF запросов и snapshot-версий обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "Поддержка AS OF запросов и snapshot-версий provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.2"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: Поддержка AS OF запросов и snapshot-версий",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.3",
    "category": "11. Управление схемой",
    "title": "Онлайн ALTER TABLE без downtime",
    "description": "Онлайн ALTER TABLE без downtime обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "Онлайн ALTER TABLE без downtime provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.3"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: Онлайн ALTER TABLE без downtime",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.4",
    "category": "11. Управление схемой",
    "title": "Instant rollback при ошибке миграции",
    "description": "Instant rollback при ошибке миграции обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "Instant rollback при ошибке миграции provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.4"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: Instant rollback при ошибке миграции",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.5",
    "category": "11. Управление схемой",
    "title": "Live reload схемы без рестарта",
    "description": "Live reload схемы без рестарта обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "Live reload схемы без рестарта provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.5"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: Live reload схемы без рестарта",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.6",
    "category": "11. Управление схемой",
    "title": "ALTER ADD/DROP/RENAME COLUMN на лету",
    "description": "ALTER ADD/DROP/RENAME COLUMN на лету обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "ALTER ADD/DROP/RENAME COLUMN на лету provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.6"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: ALTER ADD/DROP/RENAME COLUMN на лету",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.7",
    "category": "11. Управление схемой",
    "title": "ALTER TYPE и SET DEFAULT для колонок",
    "description": "ALTER TYPE и SET DEFAULT для колонок обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "ALTER TYPE и SET DEFAULT для колонок provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.7"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: ALTER TYPE и SET DEFAULT для колонок",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.8",
    "category": "11. Управление схемой",
    "title": "CREATE/DROP/RENAME/REPLACE TABLE",
    "description": "CREATE/DROP/RENAME/REPLACE TABLE обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "CREATE/DROP/RENAME/REPLACE TABLE provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.8"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: CREATE/DROP/RENAME/REPLACE TABLE",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.9",
    "category": "11. Управление схемой",
    "title": "Сравнение схем и diff tool",
    "description": "Сравнение схем и diff tool обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "Сравнение схем и diff tool provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.9"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: Сравнение схем и diff tool",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.10",
    "category": "11. Управление схемой",
    "title": "Version control для DDL-операций",
    "description": "Version control для DDL-операций обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "Version control для DDL-операций provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.10"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: Version control для DDL-операций",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.11",
    "category": "11. Управление схемой",
    "title": "Поддержка внешних описаний схем (IDL)",
    "description": "Поддержка внешних описаний схем (IDL) обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "Поддержка внешних описаний схем (IDL) provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.11"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: Поддержка внешних описаний схем (IDL)",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.12",
    "category": "11. Управление схемой",
    "title": "Типизация с точностью до JSON и структур",
    "description": "Типизация с точностью до JSON и структур обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "Типизация с точностью до JSON и структур provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.12"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: Типизация с точностью до JSON и структур",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.13",
    "category": "11. Управление схемой",
    "title": "Гибкие ограничения: NOT NULL, CHECK, FK",
    "description": "Гибкие ограничения: NOT NULL, CHECK, FK обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "Гибкие ограничения: NOT NULL, CHECK, FK provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.13"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: Гибкие ограничения: NOT NULL, CHECK, FK",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.14",
    "category": "11. Управление схемой",
    "title": "Автоматическая миграция с in-place данными",
    "description": "Автоматическая миграция с in-place данными обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "Автоматическая миграция с in-place данными provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.14"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: Автоматическая миграция с in-place данными",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.15",
    "category": "11. Управление схемой",
    "title": "Атомарные транзакции для DDL",
    "description": "Атомарные транзакции для DDL обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "Атомарные транзакции для DDL provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.15"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: Атомарные транзакции для DDL",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.16",
    "category": "11. Управление схемой",
    "title": "DDL-планировщик: отложенные изменения",
    "description": "DDL-планировщик: отложенные изменения обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "DDL-планировщик: отложенные изменения provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.16"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: DDL-планировщик: отложенные изменения",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.17",
    "category": "11. Управление схемой",
    "title": "Индексация схем и метаданных",
    "description": "Индексация схем и метаданных обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "Индексация схем и метаданных provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.17"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: Индексация схем и метаданных",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.18",
    "category": "11. Управление схемой",
    "title": "Тайм-ауты и TTL для временных таблиц",
    "description": "Тайм-ауты и TTL для временных таблиц обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "Тайм-ауты и TTL для временных таблиц provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.18"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: Тайм-ауты и TTL для временных таблиц",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.19",
    "category": "11. Управление схемой",
    "title": "Контроль доступа к DDL по ролям",
    "description": "Контроль доступа к DDL по ролям обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "Контроль доступа к DDL по ролям provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.19"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: Контроль доступа к DDL по ролям",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-11.20",
    "category": "11. Управление схемой",
    "title": "Модуль миграций со схемами обратной совместимости",
    "description": "Модуль миграций со схемами обратной совместимости обеспечивает гибкость и отказоустойчивость управления схемой в условиях high-availability, multi-tenant и mixed workloads.",
    "description_en": "Модуль миграций со схемами обратной совместимости provides flexible and fault-tolerant schema management in high-availability, multi-tenant, and mixed workload environments.",
    "test_type": "schema",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "11.20"
    ],
    "code_module": "src/schema.c",
    "responsible_roles": [
      "schema_engineer",
      "ddl_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 500000
    },
    "test_spec": {
      "goal": "Проверка управления схемой: Модуль миграций со схемами обратной совместимости",
      "input": [
        "DDL-операции",
        "онлайн-изменения",
        "откат"
      ],
      "expected": [
        "нет downtime",
        "данные целы",
        "схема корректна"
      ],
      "tools": [
        "ddl runner",
        "schema diff",
        "migration tester"
      ]
    }
  },
  {
    "id": "REQ-12.1",
    "category": "12. Форматы данных и локализация",
    "title": "Поддержка форматов данных: UTF-8, JSON, числовые, даты, timestamps",
    "description": "Поддержка форматов данных: UTF-8, JSON, числовые, даты, timestamps необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Поддержка форматов данных: UTF-8, JSON, числовые, даты, timestamps must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.1"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Поддержка форматов данных: UTF-8, JSON, числовые, даты, timestamps",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.2",
    "category": "12. Форматы данных и локализация",
    "title": "Наносекундная точность timestamps во всех операциях",
    "description": "Наносекундная точность timestamps во всех операциях необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Наносекундная точность timestamps во всех операциях must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.2"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Наносекундная точность timestamps во всех операциях",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.3",
    "category": "12. Форматы данных и локализация",
    "title": "Поддержка SYSTEM TIME в колонках и системных представлениях",
    "description": "Поддержка SYSTEM TIME в колонках и системных представлениях необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Поддержка SYSTEM TIME в колонках и системных представлениях must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.3"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Поддержка SYSTEM TIME в колонках и системных представлениях",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.4",
    "category": "12. Форматы данных и локализация",
    "title": "Автоматическое преобразование форматов CSV/JSON/XML в таблицы",
    "description": "Автоматическое преобразование форматов CSV/JSON/XML в таблицы необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Автоматическое преобразование форматов CSV/JSON/XML в таблицы must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.4"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Автоматическое преобразование форматов CSV/JSON/XML в таблицы",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.5",
    "category": "12. Форматы данных и локализация",
    "title": "Поддержка JSON Schema и валидации типов",
    "description": "Поддержка JSON Schema и валидации типов необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Поддержка JSON Schema и валидации типов must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.5"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Поддержка JSON Schema и валидации типов",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.6",
    "category": "12. Форматы данных и локализация",
    "title": "Встроенные функции обработки JSONPath, XPath",
    "description": "Встроенные функции обработки JSONPath, XPath необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Встроенные функции обработки JSONPath, XPath must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.6"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Встроенные функции обработки JSONPath, XPath",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.7",
    "category": "12. Форматы данных и локализация",
    "title": "Полная поддержка ICU collation",
    "description": "Полная поддержка ICU collation необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Полная поддержка ICU collation must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.7"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Полная поддержка ICU collation",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.8",
    "category": "12. Форматы данных и локализация",
    "title": "Локализация чисел, валют, дат по настройке клиента",
    "description": "Локализация чисел, валют, дат по настройке клиента необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Локализация чисел, валют, дат по настройке клиента must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.8"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Локализация чисел, валют, дат по настройке клиента",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.9",
    "category": "12. Форматы данных и локализация",
    "title": "Интеграция с timezones и переходами DST",
    "description": "Интеграция с timezones и переходами DST необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Интеграция с timezones и переходами DST must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.9"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Интеграция с timezones и переходами DST",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.10",
    "category": "12. Форматы данных и локализация",
    "title": "Многоязыковые функции: перевод, сравнение, case-fold",
    "description": "Многоязыковые функции: перевод, сравнение, case-fold необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Многоязыковые функции: перевод, сравнение, case-fold must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.10"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Многоязыковые функции: перевод, сравнение, case-fold",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.11",
    "category": "12. Форматы данных и локализация",
    "title": "Unicode-aware индексация и LIKE/ILIKE поведение",
    "description": "Unicode-aware индексация и LIKE/ILIKE поведение необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Unicode-aware индексация и LIKE/ILIKE поведение must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.11"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Unicode-aware индексация и LIKE/ILIKE поведение",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.12",
    "category": "12. Форматы данных и локализация",
    "title": "Сортировка и сравнение строк с учётом локали",
    "description": "Сортировка и сравнение строк с учётом локали необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Сортировка и сравнение строк с учётом локали must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.12"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Сортировка и сравнение строк с учётом локали",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.13",
    "category": "12. Форматы данных и локализация",
    "title": "Сопоставление регулярных выражений с Unicode-диапазонами",
    "description": "Сопоставление регулярных выражений с Unicode-диапазонами необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Сопоставление регулярных выражений с Unicode-диапазонами must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.13"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Сопоставление регулярных выражений с Unicode-диапазонами",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.14",
    "category": "12. Форматы данных и локализация",
    "title": "Локализованный output: JSON, CSV, текстовые поля",
    "description": "Локализованный output: JSON, CSV, текстовые поля необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Локализованный output: JSON, CSV, текстовые поля must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.14"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Локализованный output: JSON, CSV, текстовые поля",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.15",
    "category": "12. Форматы данных и локализация",
    "title": "Поддержка MULTILINGUAL / TRANSLATABLE колонок",
    "description": "Поддержка MULTILINGUAL / TRANSLATABLE колонок необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Поддержка MULTILINGUAL / TRANSLATABLE колонок must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.15"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Поддержка MULTILINGUAL / TRANSLATABLE колонок",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.16",
    "category": "12. Форматы данных и локализация",
    "title": "Адаптация форматирования под язык интерфейса",
    "description": "Адаптация форматирования под язык интерфейса необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Адаптация форматирования под язык интерфейса must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.16"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Адаптация форматирования под язык интерфейса",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.17",
    "category": "12. Форматы данных и локализация",
    "title": "Конвертация дат/времени между календарями (григорианский, исламский и т.п.)",
    "description": "Конвертация дат/времени между календарями (григорианский, исламский и т.п.) необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Конвертация дат/времени между календарями (григорианский, исламский и т.п.) must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.17"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Конвертация дат/времени между календарями (григорианский, исламский и т.п.)",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.18",
    "category": "12. Форматы данных и локализация",
    "title": "Интерфейс выбора языка и локали через SQL",
    "description": "Интерфейс выбора языка и локали через SQL необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Интерфейс выбора языка и локали через SQL must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.18"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Интерфейс выбора языка и локали через SQL",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.19",
    "category": "12. Форматы данных и локализация",
    "title": "Форматирование ошибок и сообщений в соответствии с локалью",
    "description": "Форматирование ошибок и сообщений в соответствии с локалью необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Форматирование ошибок и сообщений в соответствии с локалью must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.19"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Форматирование ошибок и сообщений в соответствии с локалью",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-12.20",
    "category": "12. Форматы данных и локализация",
    "title": "Импорт/экспорт мультиязычных данных через ETL",
    "description": "Импорт/экспорт мультиязычных данных через ETL необходимо реализовать с учетом корректного поведения при различных языках, кодировках и пользовательских форматах.",
    "description_en": "Импорт/экспорт мультиязычных данных через ETL must be implemented with correct handling of various languages, encodings, and user-defined formats.",
    "test_type": "localization",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "12.20"
    ],
    "code_module": "src/localization.c",
    "responsible_roles": [
      "localization_engineer",
      "intl_formats_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка локализованной поддержки: Импорт/экспорт мультиязычных данных через ETL",
      "input": [
        "локализованные строки",
        "форматы дат",
        "JSON с Unicode"
      ],
      "expected": [
        "форматы корректны",
        "сортировка по локали",
        "ошибки на языке клиента"
      ],
      "tools": [
        "locale test runner",
        "ICU checker",
        "unicode validator"
      ]
    }
  },
  {
    "id": "REQ-13.1",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Поддержка TTL на уровне таблиц и партиций",
    "description": "Поддержка TTL на уровне таблиц и партиций необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Поддержка TTL на уровне таблиц и партиций must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.1"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Поддержка TTL на уровне таблиц и партиций",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.2",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Автоматическое перемещение данных в холодное хранилище",
    "description": "Автоматическое перемещение данных в холодное хранилище необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Автоматическое перемещение данных в холодное хранилище must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.2"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Автоматическое перемещение данных в холодное хранилище",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.3",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Гибкие политики вытеснения по возрасту и доступу",
    "description": "Гибкие политики вытеснения по возрасту и доступу необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Гибкие политики вытеснения по возрасту и доступу must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.3"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Гибкие политики вытеснения по возрасту и доступу",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.4",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Пороговые политики based on memory/disk usage",
    "description": "Пороговые политики based on memory/disk usage необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Пороговые политики based on memory/disk usage must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.4"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Пороговые политики based on memory/disk usage",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.5",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Поддержка eviction для кэшированных данных",
    "description": "Поддержка eviction для кэшированных данных необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Поддержка eviction для кэшированных данных must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.5"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Поддержка eviction для кэшированных данных",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.6",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Auto-tiering между RAM / SSD / NVMe",
    "description": "Auto-tiering между RAM / SSD / NVMe необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Auto-tiering между RAM / SSD / NVMe must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.6"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Auto-tiering между RAM / SSD / NVMe",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.7",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Классификация данных по hot/warm/cold",
    "description": "Классификация данных по hot/warm/cold необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Классификация данных по hot/warm/cold must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.7"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Классификация данных по hot/warm/cold",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.8",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Приоритет вытеснения: по важности, частоте, SLA",
    "description": "Приоритет вытеснения: по важности, частоте, SLA необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Приоритет вытеснения: по важности, частоте, SLA must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.8"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Приоритет вытеснения: по важности, частоте, SLA",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.9",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Переход данных в read-only режим перед вытеснением",
    "description": "Переход данных в read-only режим перед вытеснением необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Переход данных в read-only режим перед вытеснением must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.9"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Переход данных в read-only режим перед вытеснением",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.10",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Асинхронная выгрузка snapshot-данных в tiered storage",
    "description": "Асинхронная выгрузка snapshot-данных в tiered storage необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Асинхронная выгрузка snapshot-данных в tiered storage must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.10"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Асинхронная выгрузка snapshot-данных в tiered storage",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.11",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Автоматическая репликация холодных слоёв",
    "description": "Автоматическая репликация холодных слоёв необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Автоматическая репликация холодных слоёв must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.11"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Автоматическая репликация холодных слоёв",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.12",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Визуализация статистики TTL/eviction",
    "description": "Визуализация статистики TTL/eviction необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Визуализация статистики TTL/eviction must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.12"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Визуализация статистики TTL/eviction",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.13",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Pushdown TTL фильтров в planner/executor",
    "description": "Pushdown TTL фильтров в planner/executor необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Pushdown TTL фильтров в planner/executor must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.13"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Pushdown TTL фильтров в planner/executor",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.14",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Возможность отмены TTL по условиям / ролям",
    "description": "Возможность отмены TTL по условиям / ролям необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Возможность отмены TTL по условиям / ролям must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.14"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Возможность отмены TTL по условиям / ролям",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.15",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Мгновенная очистка expired ключей",
    "description": "Мгновенная очистка expired ключей необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Мгновенная очистка expired ключей must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.15"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Мгновенная очистка expired ключей",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.16",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "События TTL-expiry с webhook-поддержкой",
    "description": "События TTL-expiry с webhook-поддержкой необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "События TTL-expiry с webhook-поддержкой must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.16"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: События TTL-expiry с webhook-поддержкой",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.17",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Разделение eviction на soft/hard режимы",
    "description": "Разделение eviction на soft/hard режимы необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Разделение eviction на soft/hard режимы must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.17"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Разделение eviction на soft/hard режимы",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.18",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Реализация eviction-aware сканера и индексера",
    "description": "Реализация eviction-aware сканера и индексера необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Реализация eviction-aware сканера и индексера must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.18"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Реализация eviction-aware сканера и индексера",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.19",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Поддержка eviction TTL на уровне JSON store",
    "description": "Поддержка eviction TTL на уровне JSON store необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Поддержка eviction TTL на уровне JSON store must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.19"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Поддержка eviction TTL на уровне JSON store",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-13.20",
    "category": "13. TTL, Eviction, Auto-tiering",
    "title": "Протокол наблюдаемости TTL на Prometheus + OpenTelemetry",
    "description": "Протокол наблюдаемости TTL на Prometheus + OpenTelemetry необходимо реализовать с полной поддержкой политики жизненного цикла данных, авторазгрузки и балансировки нагрузки.",
    "description_en": "Протокол наблюдаемости TTL на Prometheus + OpenTelemetry must fully support data lifecycle policy, auto-offloading, and workload balancing.",
    "test_type": "storage",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "13.20"
    ],
    "code_module": "src/tier.c",
    "responsible_roles": [
      "storage_engineer",
      "data_lifecycle_architect"
    ],
    "perf_budget_ns": {
      "init": 1000000,
      "runtime": 750000
    },
    "test_spec": {
      "goal": "Проверка TTL/Eviction/Auto-tiering: Протокол наблюдаемости TTL на Prometheus + OpenTelemetry",
      "input": [
        "данные с TTL",
        "истекающие ключи",
        "нагрузка на память"
      ],
      "expected": [
        "вытеснение прошло",
        "данные архивированы",
        "нет перегрузки"
      ],
      "tools": [
        "ttl simulator",
        "eviction monitor",
        "tier tester"
      ]
    }
  },
  {
    "id": "REQ-14.1",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Поддержка автоматического шардирования",
    "description": "Поддержка автоматического шардирования необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Поддержка автоматического шардирования must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.1"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Поддержка автоматического шардирования",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.2",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Автоматическая ребалансировка по нагрузке",
    "description": "Автоматическая ребалансировка по нагрузке необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Автоматическая ребалансировка по нагрузке must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.2"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Автоматическая ребалансировка по нагрузке",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.3",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Поддержка manual и auto partitioning",
    "description": "Поддержка manual и auto partitioning необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Поддержка manual и auto partitioning must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.3"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Поддержка manual и auto partitioning",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.4",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Distributed planner-aware query executor",
    "description": "Distributed planner-aware query executor необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Distributed planner-aware query executor must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.4"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Distributed planner-aware query executor",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.5",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Repartitioning без downtime и миграция",
    "description": "Repartitioning без downtime и миграция необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Repartitioning без downtime и миграция must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.5"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Repartitioning без downtime и миграция",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.6",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Поддержка federated execution across nodes",
    "description": "Поддержка federated execution across nodes необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Поддержка federated execution across nodes must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.6"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Поддержка federated execution across nodes",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.7",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Анализ hotspot-узлов и auto-rebalancing",
    "description": "Анализ hotspot-узлов и auto-rebalancing необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Анализ hotspot-узлов и auto-rebalancing must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.7"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Анализ hotspot-узлов и auto-rebalancing",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.8",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Интеграция с кластерным планировщиком задач",
    "description": "Интеграция с кластерным планировщиком задач необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Интеграция с кластерным планировщиком задач must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.8"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Интеграция с кластерным планировщиком задач",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.9",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Support for cross-shard joins и распределённые агрегаты",
    "description": "Support for cross-shard joins и распределённые агрегаты необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Support for cross-shard joins и распределённые агрегаты must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.9"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Support for cross-shard joins и распределённые агрегаты",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.10",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Tier-aware rebalance: hot→cold→replica",
    "description": "Tier-aware rebalance: hot→cold→replica необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Tier-aware rebalance: hot→cold→replica must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.10"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Tier-aware rebalance: hot→cold→replica",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.11",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Контроль нагрузки per node/shard/tenant",
    "description": "Контроль нагрузки per node/shard/tenant необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Контроль нагрузки per node/shard/tenant must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.11"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Контроль нагрузки per node/shard/tenant",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.12",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Планировщик шардов: latency-aware, capacity-aware",
    "description": "Планировщик шардов: latency-aware, capacity-aware необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Планировщик шардов: latency-aware, capacity-aware must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.12"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Планировщик шардов: latency-aware, capacity-aware",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.13",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Поддержка SQL-конструкций: SHARD KEY, DISTRIBUTE BY",
    "description": "Поддержка SQL-конструкций: SHARD KEY, DISTRIBUTE BY необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Поддержка SQL-конструкций: SHARD KEY, DISTRIBUTE BY must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.13"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Поддержка SQL-конструкций: SHARD KEY, DISTRIBUTE BY",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.14",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Расчёт стоимости миграции и приоритетность",
    "description": "Расчёт стоимости миграции и приоритетность необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Расчёт стоимости миграции и приоритетность must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.14"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Расчёт стоимости миграции и приоритетность",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.15",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Планировщик ребалансировки с SLA-aware логикой",
    "description": "Планировщик ребалансировки с SLA-aware логикой необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Планировщик ребалансировки с SLA-aware логикой must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.15"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Планировщик ребалансировки с SLA-aware логикой",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.16",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Интеграция с observability метриками",
    "description": "Интеграция с observability метриками необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Интеграция с observability метриками must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.16"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Интеграция с observability метриками",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.17",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Контроль consistency и quorum во время миграции",
    "description": "Контроль consistency и quorum во время миграции необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Контроль consistency и quorum во время миграции must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.17"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Контроль consistency и quorum во время миграции",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.18",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Возможность паузы/отката операции ребалансировки",
    "description": "Возможность паузы/отката операции ребалансировки необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Возможность паузы/отката операции ребалансировки must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.18"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Возможность паузы/отката операции ребалансировки",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.19",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Администрирование ребаланса через CLI/API",
    "description": "Администрирование ребаланса через CLI/API необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Администрирование ребаланса через CLI/API must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.19"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Администрирование ребаланса через CLI/API",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-14.20",
    "category": "14. Авто ребалансировка и распределение",
    "title": "Режим работы в смешанной среде: geo-distributed clusters",
    "description": "Режим работы в смешанной среде: geo-distributed clusters необходимо реализовать с учётом динамической нагрузки, SLA, шардирования и согласованности данных в кластере.",
    "description_en": "Режим работы в смешанной среде: geo-distributed clusters must be implemented considering dynamic load, SLA, sharding, and cluster data consistency.",
    "test_type": "distributed",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "14.20"
    ],
    "code_module": "src/shard.c",
    "responsible_roles": [
      "distributed_architect",
      "cluster_engineer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка auto-rebalancing & distribution: Режим работы в смешанной среде: geo-distributed clusters",
      "input": [
        "нагрузка на shard",
        "топология",
        "SLA"
      ],
      "expected": [
        "hotspot устранён",
        "данные перераспределены",
        "кластер стабилен"
      ],
      "tools": [
        "rebalance simulator",
        "cluster tracer",
        "load monitor"
      ]
    }
  },
  {
    "id": "REQ-15.1",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Семантика AS OF TIMESTAMP в SELECT-запросах",
    "description": "Семантика AS OF TIMESTAMP в SELECT-запросах необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Семантика AS OF TIMESTAMP в SELECT-запросах must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.1"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Семантика AS OF TIMESTAMP в SELECT-запросах",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.2",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Снапшоты с поддержкой времени и MVCC цепочек",
    "description": "Снапшоты с поддержкой времени и MVCC цепочек необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Снапшоты с поддержкой времени и MVCC цепочек must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.2"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Снапшоты с поддержкой времени и MVCC цепочек",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.3",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Версионирование на уровне строк (row-version chains)",
    "description": "Версионирование на уровне строк (row-version chains) необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Версионирование на уровне строк (row-version chains) must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.3"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Версионирование на уровне строк (row-version chains)",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.4",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Поддержка чтения snapshot без блокировок",
    "description": "Поддержка чтения snapshot без блокировок необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Поддержка чтения snapshot без блокировок must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.4"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Поддержка чтения snapshot без блокировок",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.5",
    "category": "15. Поддержка системной версии AS OF",
    "title": "AS OF с точностью до наносекунды",
    "description": "AS OF с точностью до наносекунды необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "AS OF с точностью до наносекунды must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.5"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: AS OF с точностью до наносекунды",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.6",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Запросы AS OF поддерживают JOIN, WHERE, GROUP BY",
    "description": "Запросы AS OF поддерживают JOIN, WHERE, GROUP BY необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Запросы AS OF поддерживают JOIN, WHERE, GROUP BY must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.6"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Запросы AS OF поддерживают JOIN, WHERE, GROUP BY",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.7",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Оптимизация snapshot-запросов через индекс времени",
    "description": "Оптимизация snapshot-запросов через индекс времени необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Оптимизация snapshot-запросов через индекс времени must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.7"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Оптимизация snapshot-запросов через индекс времени",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.8",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Поддержка системного времени в столбцах (GENERATED ALWAYS)",
    "description": "Поддержка системного времени в столбцах (GENERATED ALWAYS) необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Поддержка системного времени в столбцах (GENERATED ALWAYS) must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.8"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Поддержка системного времени в столбцах (GENERATED ALWAYS)",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.9",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Сравнение версий и аудит изменений между snapshot'ами",
    "description": "Сравнение версий и аудит изменений между snapshot'ами необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Сравнение версий и аудит изменений между snapshot'ами must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.9"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Сравнение версий и аудит изменений между snapshot'ами",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.10",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Функции версии: row_version_start, row_version_end",
    "description": "Функции версии: row_version_start, row_version_end необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Функции версии: row_version_start, row_version_end must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.10"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Функции версии: row_version_start, row_version_end",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.11",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Сохранение snapshot в WAL и snapshot-файлы",
    "description": "Сохранение snapshot в WAL и snapshot-файлы необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Сохранение snapshot в WAL и snapshot-файлы must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.11"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Сохранение snapshot в WAL и snapshot-файлы",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.12",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Сжатие и дедупликация версий при snapshot-сохранении",
    "description": "Сжатие и дедупликация версий при snapshot-сохранении необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Сжатие и дедупликация версий при snapshot-сохранении must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.12"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Сжатие и дедупликация версий при snapshot-сохранении",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.13",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Встроенные snapshot-процедуры в SQL: SNAPSHOT CREATE/READ/DELETE",
    "description": "Встроенные snapshot-процедуры в SQL: SNAPSHOT CREATE/READ/DELETE необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Встроенные snapshot-процедуры в SQL: SNAPSHOT CREATE/READ/DELETE must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.13"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Встроенные snapshot-процедуры в SQL: SNAPSHOT CREATE/READ/DELETE",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.14",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Автоматическая очистка устаревших версий по TTL",
    "description": "Автоматическая очистка устаревших версий по TTL необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Автоматическая очистка устаревших версий по TTL must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.14"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Автоматическая очистка устаревших версий по TTL",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.15",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Управление snapshot TTL и retention policy",
    "description": "Управление snapshot TTL и retention policy необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Управление snapshot TTL и retention policy must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.15"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Управление snapshot TTL и retention policy",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.16",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Поддержка snapshot в транзакциях и консистентности MVCC",
    "description": "Поддержка snapshot в транзакциях и консистентности MVCC необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Поддержка snapshot в транзакциях и консистентности MVCC must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.16"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Поддержка snapshot в транзакциях и консистентности MVCC",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.17",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Интеграция с CDC и Changefeed для snapshot данных",
    "description": "Интеграция с CDC и Changefeed для snapshot данных необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Интеграция с CDC и Changefeed для snapshot данных must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.17"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Интеграция с CDC и Changefeed для snapshot данных",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.18",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Репликация snapshot-состояний в DR-узлы",
    "description": "Репликация snapshot-состояний в DR-узлы необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Репликация snapshot-состояний в DR-узлы must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.18"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Репликация snapshot-состояний в DR-узлы",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.19",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Визуализация разницы между snapshot-версиями",
    "description": "Визуализация разницы между snapshot-версиями необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Визуализация разницы между snapshot-версиями must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.19"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Визуализация разницы между snapshot-версиями",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-15.20",
    "category": "15. Поддержка системной версии AS OF",
    "title": "Система контроля изменений (version diff engine)",
    "description": "Система контроля изменений (version diff engine) необходимо реализовать в рамках полной поддержки версионности данных, snapshot isolation и AS OF операций.",
    "description_en": "Система контроля изменений (version diff engine) must be implemented as part of full support for data versioning, snapshot isolation, and AS OF operations.",
    "test_type": "versioning",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "15.20"
    ],
    "code_module": "src/versioned.c",
    "responsible_roles": [
      "versioning_engineer",
      "mvcc_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1500000
    },
    "test_spec": {
      "goal": "Проверка AS OF / Snapshot: Система контроля изменений (version diff engine)",
      "input": [
        "SELECT AS OF",
        "timestamp",
        "старые и новые строки"
      ],
      "expected": [
        "данные корректны",
        "версии видимы",
        "нет конфликтов"
      ],
      "tools": [
        "snapshot tester",
        "mvcc visualizer",
        "asof query runner"
      ]
    }
  },
  {
    "id": "REQ-16.1",
    "category": "16. Поддержка большого объема памяти",
    "title": "NUMA-aware аллокация памяти",
    "description": "NUMA-aware аллокация памяти должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "NUMA-aware аллокация памяти must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.1"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: NUMA-aware аллокация памяти",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.2",
    "category": "16. Поддержка большого объема памяти",
    "title": "CPU affinity и binding потоков к NUMA-узлам",
    "description": "CPU affinity и binding потоков к NUMA-узлам должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "CPU affinity и binding потоков к NUMA-узлам must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.2"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: CPU affinity и binding потоков к NUMA-узлам",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.3",
    "category": "16. Поддержка большого объема памяти",
    "title": "Cache coloring и prefetch-подсказки",
    "description": "Cache coloring и prefetch-подсказки должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Cache coloring и prefetch-подсказки must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.3"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Cache coloring и prefetch-подсказки",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.4",
    "category": "16. Поддержка большого объема памяти",
    "title": "Память > 1 ТБ на узел, в том числе для column-store",
    "description": "Память > 1 ТБ на узел, в том числе для column-store должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Память > 1 ТБ на узел, в том числе для column-store must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.4"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Память > 1 ТБ на узел, в том числе для column-store",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.5",
    "category": "16. Поддержка большого объема памяти",
    "title": "Оптимизация кэширования с учетом L1/L2/L3 и NUMA",
    "description": "Оптимизация кэширования с учетом L1/L2/L3 и NUMA должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Оптимизация кэширования с учетом L1/L2/L3 и NUMA must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.5"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Оптимизация кэширования с учетом L1/L2/L3 и NUMA",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.6",
    "category": "16. Поддержка большого объема памяти",
    "title": "Adaptive slab allocator под in-memory нагрузки",
    "description": "Adaptive slab allocator под in-memory нагрузки должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Adaptive slab allocator под in-memory нагрузки must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.6"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Adaptive slab allocator под in-memory нагрузки",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.7",
    "category": "16. Поддержка большого объема памяти",
    "title": "Статистика аллокаций по NUMA, процессам, таблицам",
    "description": "Статистика аллокаций по NUMA, процессам, таблицам должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Статистика аллокаций по NUMA, процессам, таблицам must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.7"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Статистика аллокаций по NUMA, процессам, таблицам",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.8",
    "category": "16. Поддержка большого объема памяти",
    "title": "Управление слоями памяти: fast / large / mapped",
    "description": "Управление слоями памяти: fast / large / mapped должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Управление слоями памяти: fast / large / mapped must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.8"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Управление слоями памяти: fast / large / mapped",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.9",
    "category": "16. Поддержка большого объема памяти",
    "title": "Zero-copy и page-aligned буферы",
    "description": "Zero-copy и page-aligned буферы должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Zero-copy и page-aligned буферы must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.9"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Zero-copy и page-aligned буферы",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.10",
    "category": "16. Поддержка большого объема памяти",
    "title": "Отложенное выделение памяти и lazy instantiation",
    "description": "Отложенное выделение памяти и lazy instantiation должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Отложенное выделение памяти и lazy instantiation must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.10"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Отложенное выделение памяти и lazy instantiation",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.11",
    "category": "16. Поддержка большого объема памяти",
    "title": "Аллокация по приоритетам (hot, temp, cache, buffer)",
    "description": "Аллокация по приоритетам (hot, temp, cache, buffer) должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Аллокация по приоритетам (hot, temp, cache, buffer) must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.11"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Аллокация по приоритетам (hot, temp, cache, buffer)",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.12",
    "category": "16. Поддержка большого объема памяти",
    "title": "Контроль фрагментации и инструменты defragmentation",
    "description": "Контроль фрагментации и инструменты defragmentation должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Контроль фрагментации и инструменты defragmentation must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.12"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Контроль фрагментации и инструменты defragmentation",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.13",
    "category": "16. Поддержка большого объема памяти",
    "title": "Быстрое клонирование и reset in-memory таблиц",
    "description": "Быстрое клонирование и reset in-memory таблиц должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Быстрое клонирование и reset in-memory таблиц must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.13"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Быстрое клонирование и reset in-memory таблиц",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.14",
    "category": "16. Поддержка большого объема памяти",
    "title": "Мгновенная загрузка snapshot в память",
    "description": "Мгновенная загрузка snapshot в память должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Мгновенная загрузка snapshot в память must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.14"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Мгновенная загрузка snapshot в память",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.15",
    "category": "16. Поддержка большого объема памяти",
    "title": "Параллельная инициализация памяти на старте",
    "description": "Параллельная инициализация памяти на старте должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Параллельная инициализация памяти на старте must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.15"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Параллельная инициализация памяти на старте",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.16",
    "category": "16. Поддержка большого объема памяти",
    "title": "Память под транзакции, undo/redo и MVCC цепочки",
    "description": "Память под транзакции, undo/redo и MVCC цепочки должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Память под транзакции, undo/redo и MVCC цепочки must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.16"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Память под транзакции, undo/redo и MVCC цепочки",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.17",
    "category": "16. Поддержка большого объема памяти",
    "title": "Трекинг “грязных” страниц и diff-based snapshot",
    "description": "Трекинг “грязных” страниц и diff-based snapshot должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Трекинг “грязных” страниц и diff-based snapshot must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.17"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Трекинг “грязных” страниц и diff-based snapshot",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.18",
    "category": "16. Поддержка большого объема памяти",
    "title": "Приоритетная выгрузка slab/slack объектов",
    "description": "Приоритетная выгрузка slab/slack объектов должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Приоритетная выгрузка slab/slack объектов must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.18"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Приоритетная выгрузка slab/slack объектов",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.19",
    "category": "16. Поддержка большого объема памяти",
    "title": "Динамический прогноз потребления памяти",
    "description": "Динамический прогноз потребления памяти должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Динамический прогноз потребления памяти must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.19"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Динамический прогноз потребления памяти",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-16.20",
    "category": "16. Поддержка большого объема памяти",
    "title": "Мониторинг на уровне tenant/session/query по памяти",
    "description": "Мониторинг на уровне tenant/session/query по памяти должно быть реализовано для эффективного управления, анализа и эксплуатации большого объема in-memory памяти в многопоточном NUMA-окружении.",
    "description_en": "Мониторинг на уровне tenant/session/query по памяти must support efficient memory use, analytics, and operation in large-scale in-memory NUMA environments.",
    "test_type": "memory",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "16.20"
    ],
    "code_module": "src/memory.c",
    "responsible_roles": [
      "memory_engineer",
      "numa_allocator_architect"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка NUMA/memory management: Мониторинг на уровне tenant/session/query по памяти",
      "input": [
        "нагрузка > 1 ТБ",
        "NUMA topology",
        "многопоточный режим"
      ],
      "expected": [
        "отсутствие деградации",
        "адекватное распределение",
        "низкая фрагментация"
      ],
      "tools": [
        "memory profiler",
        "numa heatmap",
        "allocator stats"
      ]
    }
  },
  {
    "id": "REQ-17.1",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "CPU quotas per tenant/session/query",
    "description": "CPU quotas per tenant/session/query должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "CPU quotas per tenant/session/query must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.1"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: CPU quotas per tenant/session/query",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.2",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "IOPS лимиты на чтение/запись per session",
    "description": "IOPS лимиты на чтение/запись per session должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "IOPS лимиты на чтение/запись per session must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.2"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: IOPS лимиты на чтение/запись per session",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.3",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "Memory quota per tenant, shard, query",
    "description": "Memory quota per tenant, shard, query должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "Memory quota per tenant, shard, query must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.3"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: Memory quota per tenant, shard, query",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.4",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "Monitoring ресурсов по tenant_id / session_id",
    "description": "Monitoring ресурсов по tenant_id / session_id должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "Monitoring ресурсов по tenant_id / session_id must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.4"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: Monitoring ресурсов по tenant_id / session_id",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.5",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "Изоляция: per-query execution budget",
    "description": "Изоляция: per-query execution budget должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "Изоляция: per-query execution budget must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.5"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: Изоляция: per-query execution budget",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.6",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "Поддержка QoS-классов: CRITICAL, HIGH, BACKGROUND",
    "description": "Поддержка QoS-классов: CRITICAL, HIGH, BACKGROUND должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "Поддержка QoS-классов: CRITICAL, HIGH, BACKGROUND must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.6"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: Поддержка QoS-классов: CRITICAL, HIGH, BACKGROUND",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.7",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "Ограничение по времени выполнения запросов",
    "description": "Ограничение по времени выполнения запросов должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "Ограничение по времени выполнения запросов must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.7"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: Ограничение по времени выполнения запросов",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.8",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "Гибкий throttling на уровне executor/planner",
    "description": "Гибкий throttling на уровне executor/planner должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "Гибкий throttling на уровне executor/planner must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.8"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: Гибкий throttling на уровне executor/planner",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.9",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "Лимит на кол-во активных потоков per user",
    "description": "Лимит на кол-во активных потоков per user должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "Лимит на кол-во активных потоков per user must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.9"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: Лимит на кол-во активных потоков per user",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.10",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "Мониторинг превышений лимитов и логгирование",
    "description": "Мониторинг превышений лимитов и логгирование должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "Мониторинг превышений лимитов и логгирование must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.10"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: Мониторинг превышений лимитов и логгирование",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.11",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "Автоматическое понижение при превышении лимитов",
    "description": "Автоматическое понижение при превышении лимитов должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "Автоматическое понижение при превышении лимитов must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.11"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: Автоматическое понижение при превышении лимитов",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.12",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "Rate-limiting для ingestion / streaming",
    "description": "Rate-limiting для ingestion / streaming должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "Rate-limiting для ingestion / streaming must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.12"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: Rate-limiting для ingestion / streaming",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.13",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "Resource groups с приоритетами и fairness",
    "description": "Resource groups с приоритетами и fairness должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "Resource groups с приоритетами и fairness must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.13"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: Resource groups с приоритетами и fairness",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.14",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "Поддержка burst-mode с токен-бакетами",
    "description": "Поддержка burst-mode с токен-бакетами должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "Поддержка burst-mode с токен-бакетами must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.14"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: Поддержка burst-mode с токен-бакетами",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.15",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "Лимиты на DDL и админ-операции per tenant",
    "description": "Лимиты на DDL и админ-операции per tenant должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "Лимиты на DDL и админ-операции per tenant must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.15"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: Лимиты на DDL и админ-операции per tenant",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.16",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "Ограничения на соединения, pool-size, TX-rate",
    "description": "Ограничения на соединения, pool-size, TX-rate должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "Ограничения на соединения, pool-size, TX-rate must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.16"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: Ограничения на соединения, pool-size, TX-rate",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.17",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "Индивидуальные SLA per tenant и их проверка",
    "description": "Индивидуальные SLA per tenant и их проверка должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "Индивидуальные SLA per tenant и их проверка must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.17"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: Индивидуальные SLA per tenant и их проверка",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.18",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "Нотификация при достижении порогов",
    "description": "Нотификация при достижении порогов должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "Нотификация при достижении порогов must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.18"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: Нотификация при достижении порогов",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.19",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "API и CLI для динамического конфигурирования квот",
    "description": "API и CLI для динамического конфигурирования квот должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "API и CLI для динамического конфигурирования квот must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.19"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: API и CLI для динамического конфигурирования квот",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-17.20",
    "category": "17. Ограничения по CPU/IOPS/Memory, multi-tenant",
    "title": "Автоматический rollback при out-of-quota",
    "description": "Автоматический rollback при out-of-quota должно обеспечивать контроль и соблюдение SLA в условиях многопользовательской нагрузки с изоляцией ресурсов и приоритизацией.",
    "description_en": "Автоматический rollback при out-of-quota must ensure SLA enforcement under multi-tenant workloads with full resource isolation and prioritization.",
    "test_type": "resource_control",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "17.20"
    ],
    "code_module": "src/qos.c",
    "responsible_roles": [
      "qos_engineer",
      "multi_tenant_architect"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка квот/ограничений: Автоматический rollback при out-of-quota",
      "input": [
        "многопользовательская нагрузка",
        "burst",
        "QoS трафик"
      ],
      "expected": [
        "лимиты соблюдены",
        "изоляция сохранена",
        "приоритеты работают"
      ],
      "tools": [
        "quota tester",
        "resource monitor",
        "qos benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.1",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Внутренний формат хранения: PAX layout",
    "description": "Внутренний формат хранения: PAX layout необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Внутренний формат хранения: PAX layout must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.1"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Внутренний формат хранения: PAX layout",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.2",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Поддержка Apache Arrow layout для in-memory структур",
    "description": "Поддержка Apache Arrow layout для in-memory структур необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Поддержка Apache Arrow layout для in-memory структур must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.2"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Поддержка Apache Arrow layout для in-memory структур",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.3",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Zero-copy преобразование в Arrow",
    "description": "Zero-copy преобразование в Arrow необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Zero-copy преобразование в Arrow must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.3"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Zero-copy преобразование в Arrow",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.4",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Оптимизация кэш-выравнивания данных в PAX",
    "description": "Оптимизация кэш-выравнивания данных в PAX необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Оптимизация кэш-выравнивания данных в PAX must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.4"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Оптимизация кэш-выравнивания данных в PAX",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.5",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Интеграция Arrow с векторными операторами",
    "description": "Интеграция Arrow с векторными операторами необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Интеграция Arrow с векторными операторами must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.5"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Интеграция Arrow с векторными операторами",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.6",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Поддержка Arrow IPC и Flight Protocol",
    "description": "Поддержка Arrow IPC и Flight Protocol необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Поддержка Arrow IPC и Flight Protocol must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.6"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Поддержка Arrow IPC и Flight Protocol",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.7",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Конвертация row → column и column → row в PAX",
    "description": "Конвертация row → column и column → row в PAX необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Конвертация row → column и column → row в PAX must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.7"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Конвертация row → column и column → row в PAX",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.8",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Статистика доступа по layout-блокам",
    "description": "Статистика доступа по layout-блокам необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Статистика доступа по layout-блокам must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.8"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Статистика доступа по layout-блокам",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.9",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Prefetch / batch scan в формате Arrow",
    "description": "Prefetch / batch scan в формате Arrow необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Prefetch / batch scan в формате Arrow must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.9"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Prefetch / batch scan в формате Arrow",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.10",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Встроенный schema descriptor совместимый с Arrow",
    "description": "Встроенный schema descriptor совместимый с Arrow необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Встроенный schema descriptor совместимый с Arrow must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.10"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Встроенный schema descriptor совместимый с Arrow",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.11",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Профилировка и трассировка layout-переходов",
    "description": "Профилировка и трассировка layout-переходов необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Профилировка и трассировка layout-переходов must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.11"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Профилировка и трассировка layout-переходов",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.12",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Совместимость Arrow layout с UDF/ML модулями",
    "description": "Совместимость Arrow layout с UDF/ML модулями необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Совместимость Arrow layout с UDF/ML модулями must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.12"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Совместимость Arrow layout с UDF/ML модулями",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.13",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Поддержка Arrow в плагинах и внешних функциях",
    "description": "Поддержка Arrow в плагинах и внешних функциях необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Поддержка Arrow в плагинах и внешних функциях must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.13"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Поддержка Arrow в плагинах и внешних функциях",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.14",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Производительность: SIMD-aware обработка Arrow batch",
    "description": "Производительность: SIMD-aware обработка Arrow batch необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Производительность: SIMD-aware обработка Arrow batch must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.14"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Производительность: SIMD-aware обработка Arrow batch",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.15",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Автоматическое определение лучшего layout (row/PAX/column)",
    "description": "Автоматическое определение лучшего layout (row/PAX/column) необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Автоматическое определение лучшего layout (row/PAX/column) must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.15"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Автоматическое определение лучшего layout (row/PAX/column)",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.16",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Интеграция layout с buffer pool и page cache",
    "description": "Интеграция layout с buffer pool и page cache необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Интеграция layout с buffer pool и page cache must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.16"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Интеграция layout с buffer pool и page cache",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.17",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Формат-aware планировщик запросов",
    "description": "Формат-aware планировщик запросов необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Формат-aware планировщик запросов must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.17"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Формат-aware планировщик запросов",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.18",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Тестирование совместимости layout'ов",
    "description": "Тестирование совместимости layout'ов необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Тестирование совместимости layout'ов must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.18"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Тестирование совместимости layout'ов",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.19",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Метрики layout efficiency (скан/латентность)",
    "description": "Метрики layout efficiency (скан/латентность) необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Метрики layout efficiency (скан/латентность) must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.19"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Метрики layout efficiency (скан/латентность)",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-18.20",
    "category": "18. Поддержка PAX / Apache Arrow layout",
    "title": "Возможность динамического переключения layout",
    "description": "Возможность динамического переключения layout необходимо реализовать с учетом векторного исполнения, кэш-эффективности и совместимости с экосистемой Arrow.",
    "description_en": "Возможность динамического переключения layout must support vectorized execution, cache-efficiency, and compatibility with the Arrow ecosystem.",
    "test_type": "layout",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "18.20"
    ],
    "code_module": "src/layout.c",
    "responsible_roles": [
      "data_layout_engineer",
      "arrow_integration_architect"
    ],
    "perf_budget_ns": {
      "init": 1800000,
      "runtime": 1200000
    },
    "test_spec": {
      "goal": "Проверка layout'ов (PAX/Arrow): Возможность динамического переключения layout",
      "input": [
        "данные row/column",
        "Arrow batches",
        "векторные запросы"
      ],
      "expected": [
        "layout оптимален",
        "zero-copy работает",
        "векторизация включена"
      ],
      "tools": [
        "arrow scanner",
        "layout profiler",
        "batch benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.1",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Сжатие по Frame-of-Reference (FOR) для числовых колонок",
    "description": "Сжатие по Frame-of-Reference (FOR) для числовых колонок необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Сжатие по Frame-of-Reference (FOR) для числовых колонок must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.1"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Сжатие по Frame-of-Reference (FOR) для числовых колонок",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.2",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Векторное сжатие для column-store",
    "description": "Векторное сжатие для column-store необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Векторное сжатие для column-store must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.2"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Векторное сжатие для column-store",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.3",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Delta encoding на уровне блоков и батчей",
    "description": "Delta encoding на уровне блоков и батчей необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Delta encoding на уровне блоков и батчей must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.3"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Delta encoding на уровне блоков и батчей",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.4",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "RLE (run-length encoding) для повторяющихся значений",
    "description": "RLE (run-length encoding) для повторяющихся значений необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "RLE (run-length encoding) для повторяющихся значений must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.4"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: RLE (run-length encoding) для повторяющихся значений",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.5",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Dictionary encoding с быстрым поиском",
    "description": "Dictionary encoding с быстрым поиском необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Dictionary encoding с быстрым поиском must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.5"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Dictionary encoding с быстрым поиском",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.6",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Автоматическое определение типа сжатия per column",
    "description": "Автоматическое определение типа сжатия per column необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Автоматическое определение типа сжатия per column must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.6"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Автоматическое определение типа сжатия per column",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.7",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Интеграция с scan-операторами (decode on-the-fly)",
    "description": "Интеграция с scan-операторами (decode on-the-fly) необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Интеграция с scan-операторами (decode on-the-fly) must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.7"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Интеграция с scan-операторами (decode on-the-fly)",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.8",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "SIMD-ускоренная декомпрессия в векторных планах",
    "description": "SIMD-ускоренная декомпрессия в векторных планах необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "SIMD-ускоренная декомпрессия в векторных планах must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.8"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: SIMD-ускоренная декомпрессия в векторных планах",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.9",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Поддержка вложенных структур и массивов в сжатом виде",
    "description": "Поддержка вложенных структур и массивов в сжатом виде необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Поддержка вложенных структур и массивов в сжатом виде must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.9"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Поддержка вложенных структур и массивов в сжатом виде",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.10",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Встроенный анализатор эффективности сжатия",
    "description": "Встроенный анализатор эффективности сжатия необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Встроенный анализатор эффективности сжатия must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.10"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Встроенный анализатор эффективности сжатия",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.11",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Визуализация эффективности и времени декомпрессии",
    "description": "Визуализация эффективности и времени декомпрессии необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Визуализация эффективности и времени декомпрессии must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.11"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Визуализация эффективности и времени декомпрессии",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.12",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Настройка компрессии на уровне схемы и таблицы",
    "description": "Настройка компрессии на уровне схемы и таблицы необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Настройка компрессии на уровне схемы и таблицы must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.12"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Настройка компрессии на уровне схемы и таблицы",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.13",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Индексация сжатых колонок без декомпрессии",
    "description": "Индексация сжатых колонок без декомпрессии необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Индексация сжатых колонок без декомпрессии must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.13"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Индексация сжатых колонок без декомпрессии",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.14",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Декомпрессия во время JOIN и GROUP BY",
    "description": "Декомпрессия во время JOIN и GROUP BY необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Декомпрессия во время JOIN и GROUP BY must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.14"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Декомпрессия во время JOIN и GROUP BY",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.15",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Сжатие snapshot и WAL страниц",
    "description": "Сжатие snapshot и WAL страниц необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Сжатие snapshot и WAL страниц must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.15"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Сжатие snapshot и WAL страниц",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.16",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Lazy-decode при фильтрации и seek",
    "description": "Lazy-decode при фильтрации и seek необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Lazy-decode при фильтрации и seek must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.16"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Lazy-decode при фильтрации и seek",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.17",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Поддержка компрессии для JSON-типов",
    "description": "Поддержка компрессии для JSON-типов необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Поддержка компрессии для JSON-типов must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.17"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Поддержка компрессии для JSON-типов",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.18",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Zero-copy путь для already-compressed data",
    "description": "Zero-copy путь для already-compressed data необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Zero-copy путь для already-compressed data must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.18"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Zero-copy путь для already-compressed data",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.19",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Testbench и reference benchmarks по сжатию",
    "description": "Testbench и reference benchmarks по сжатию необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Testbench и reference benchmarks по сжатию must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.19"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Testbench и reference benchmarks по сжатию",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-19.20",
    "category": "19. Frame-of-Reference и векторное сжатие",
    "title": "Сжатие адаптивно к горячим/холодным данным",
    "description": "Сжатие адаптивно к горячим/холодным данным необходимо реализовать для высокой компрессии, кэш-эффективности и прозрачного исполнения сжатых планов.",
    "description_en": "Сжатие адаптивно к горячим/холодным данным must support high compression, cache efficiency, and transparent execution of compressed query plans.",
    "test_type": "compression",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "19.20"
    ],
    "code_module": "src/compression.c",
    "responsible_roles": [
      "compression_engineer",
      "columnar_optimizer"
    ],
    "perf_budget_ns": {
      "init": 1500000,
      "runtime": 1000000
    },
    "test_spec": {
      "goal": "Проверка компрессии и декомпрессии: Сжатие адаптивно к горячим/холодным данным",
      "input": [
        "колонки со сжатием",
        "batch-запросы",
        "гибридный layout"
      ],
      "expected": [
        "данные сжаты",
        "latency < 1ms",
        "векторная декомпрессия работает"
      ],
      "tools": [
        "compression tester",
        "SIMD decoder",
        "FOR benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.1",
    "category": "20. JIT, SIMD и векторизация",
    "title": "JIT-компиляция выражений SQL",
    "description": "JIT-компиляция выражений SQL необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "JIT-компиляция выражений SQL must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.1"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: JIT-компиляция выражений SQL",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.2",
    "category": "20. JIT, SIMD и векторизация",
    "title": "JIT для join- и агрегатных операторов",
    "description": "JIT для join- и агрегатных операторов необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "JIT для join- и агрегатных операторов must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.2"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: JIT для join- и агрегатных операторов",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.3",
    "category": "20. JIT, SIMD и векторизация",
    "title": "Реализация LLVM-поддержки (или аналог)",
    "description": "Реализация LLVM-поддержки (или аналог) необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "Реализация LLVM-поддержки (или аналог) must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.3"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: Реализация LLVM-поддержки (или аналог)",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.4",
    "category": "20. JIT, SIMD и векторизация",
    "title": "Генерация SIMD-инструкций в JIT-коде",
    "description": "Генерация SIMD-инструкций в JIT-коде необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "Генерация SIMD-инструкций в JIT-коде must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.4"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: Генерация SIMD-инструкций в JIT-коде",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.5",
    "category": "20. JIT, SIMD и векторизация",
    "title": "Поддержка AVX512 / NEON / SSE в runtime",
    "description": "Поддержка AVX512 / NEON / SSE в runtime необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "Поддержка AVX512 / NEON / SSE в runtime must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.5"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: Поддержка AVX512 / NEON / SSE в runtime",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.6",
    "category": "20. JIT, SIMD и векторизация",
    "title": "Автоматическое определение JIT-friendly путей",
    "description": "Автоматическое определение JIT-friendly путей необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "Автоматическое определение JIT-friendly путей must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.6"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: Автоматическое определение JIT-friendly путей",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.7",
    "category": "20. JIT, SIMD и векторизация",
    "title": "Предпочтение JIT для hot-кода и частых выражений",
    "description": "Предпочтение JIT для hot-кода и частых выражений необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "Предпочтение JIT для hot-кода и частых выражений must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.7"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: Предпочтение JIT для hot-кода и частых выражений",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.8",
    "category": "20. JIT, SIMD и векторизация",
    "title": "Векторная обработка фильтров и WHERE-условий",
    "description": "Векторная обработка фильтров и WHERE-условий необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "Векторная обработка фильтров и WHERE-условий must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.8"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: Векторная обработка фильтров и WHERE-условий",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.9",
    "category": "20. JIT, SIMD и векторизация",
    "title": "Batch-based execution с SIMD операциями",
    "description": "Batch-based execution с SIMD операциями необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "Batch-based execution с SIMD операциями must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.9"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: Batch-based execution с SIMD операциями",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.10",
    "category": "20. JIT, SIMD и векторизация",
    "title": "JIT-aware cost-based optimizer",
    "description": "JIT-aware cost-based optimizer необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "JIT-aware cost-based optimizer must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.10"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: JIT-aware cost-based optimizer",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.11",
    "category": "20. JIT, SIMD и векторизация",
    "title": "Profiler для JIT-кода и runtime-инлайн функций",
    "description": "Profiler для JIT-кода и runtime-инлайн функций необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "Profiler для JIT-кода и runtime-инлайн функций must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.11"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: Profiler для JIT-кода и runtime-инлайн функций",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.12",
    "category": "20. JIT, SIMD и векторизация",
    "title": "Генерация векторных операторов на лету",
    "description": "Генерация векторных операторов на лету необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "Генерация векторных операторов на лету must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.12"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: Генерация векторных операторов на лету",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.13",
    "category": "20. JIT, SIMD и векторизация",
    "title": "Интеграция с компилятором WASM / Lua / C DSL",
    "description": "Интеграция с компилятором WASM / Lua / C DSL необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "Интеграция с компилятором WASM / Lua / C DSL must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.13"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: Интеграция с компилятором WASM / Lua / C DSL",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.14",
    "category": "20. JIT, SIMD и векторизация",
    "title": "Dynamic recompilation по наблюдаемой статистике",
    "description": "Dynamic recompilation по наблюдаемой статистике необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "Dynamic recompilation по наблюдаемой статистике must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.14"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: Dynamic recompilation по наблюдаемой статистике",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.15",
    "category": "20. JIT, SIMD и векторизация",
    "title": "Fallback режим при ошибках JIT-компиляции",
    "description": "Fallback режим при ошибках JIT-компиляции необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "Fallback режим при ошибках JIT-компиляции must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.15"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: Fallback режим при ошибках JIT-компиляции",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.16",
    "category": "20. JIT, SIMD и векторизация",
    "title": "Визуализация JIT-IR и векторных трасс",
    "description": "Визуализация JIT-IR и векторных трасс необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "Визуализация JIT-IR и векторных трасс must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.16"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: Визуализация JIT-IR и векторных трасс",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.17",
    "category": "20. JIT, SIMD и векторизация",
    "title": "Сравнение JIT vs non-JIT планов",
    "description": "Сравнение JIT vs non-JIT планов необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "Сравнение JIT vs non-JIT планов must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.17"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: Сравнение JIT vs non-JIT планов",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.18",
    "category": "20. JIT, SIMD и векторизация",
    "title": "Контроль времени компиляции и overheard",
    "description": "Контроль времени компиляции и overheard необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "Контроль времени компиляции и overheard must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.18"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: Контроль времени компиляции и overheard",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.19",
    "category": "20. JIT, SIMD и векторизация",
    "title": "Режим предварительной компиляции UDF в bytecode",
    "description": "Режим предварительной компиляции UDF в bytecode необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "Режим предварительной компиляции UDF в bytecode must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.19"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: Режим предварительной компиляции UDF в bytecode",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  },
  {
    "id": "REQ-20.20",
    "category": "20. JIT, SIMD и векторизация",
    "title": "API расширения JIT-пайплайна внешними оптимизаторами",
    "description": "API расширения JIT-пайплайна внешними оптимизаторами необходимо реализовать с максимальной эффективностью исполнения, возможностью векторизации и динамической адаптацией.",
    "description_en": "API расширения JIT-пайплайна внешними оптимизаторами must be implemented for maximal runtime efficiency, vectorization and dynamic adaptability.",
    "test_type": "jit_vector",
    "test_coverage": "full",
    "tracing_required": true,
    "functions_to_implement": [],
    "impl_hint": [],
    "required_structures": [],
    "log_events_to_emit": [],
    "runtime_metrics_to_emit": [],
    "config_keys_used": [],
    "related_requirements": [],
    "covered_by_blocks": [
      "20.20"
    ],
    "code_module": "src/jit.c",
    "responsible_roles": [
      "jit_engineer",
      "vector_optimizer"
    ],
    "perf_budget_ns": {
      "init": 2000000,
      "runtime": 800000
    },
    "test_spec": {
      "goal": "Проверка JIT/Vector execution: API расширения JIT-пайплайна внешними оптимизаторами",
      "input": [
        "векторные запросы",
        "JIT выражения",
        "агрегации"
      ],
      "expected": [
        "ускорение > x2",
        "JIT активен",
        "SIMD инструкции работают"
      ],
      "tools": [
        "jit tracer",
        "llvm profiler",
        "vector benchmark"
      ]
    }
  }
]
